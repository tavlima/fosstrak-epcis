/*
 * Copyright (c) 2006 ETH Zurich, Switzerland. All rights reserved. For copying
 * and distribution information, please see the file LICENSE.
 */

/**
 * Separate package for Schedule to keep things a bit organized.
 */
package org.accada.epcis.repository;

import static java.util.Calendar.DAY_OF_MONTH;
import static java.util.Calendar.DAY_OF_WEEK;
import static java.util.Calendar.HOUR_OF_DAY;
import static java.util.Calendar.MINUTE;
import static java.util.Calendar.MONTH;
import static java.util.Calendar.SECOND;
import static java.util.Calendar.YEAR;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.GregorianCalendar;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.TreeSet;
import java.util.Vector;

import org.accada.epcis.soapapi.ImplementationException;
import org.accada.epcis.soapapi.ImplementationExceptionSeverity;
import org.accada.epcis.soapapi.QuerySchedule;
import org.accada.epcis.soapapi.SubscriptionControlsException;
import org.apache.log4j.Logger;

/**
 * This is a simple schedule which can return a "next scheduled time" after now
 * or a given time. It is meant to be instantiated with a EPCIS QuerySchedule
 * but could be extended to be used otherwise.
 * 
 * @author Arthur van Dorp
 */
public class Schedule implements Serializable {
    // TODO: This class has become extremely ugly and is in dire
    // need of a revamp. Lots of code duplication has to be removed.
    // Especially in the ...MadeValid() methods.

    private static final Logger LOG = Logger.getLogger(Schedule.class);

    /**
     * Autogenerated UID for serialization.
     */
    private static final long serialVersionUID = -2930237937444822557L;

    /**
     * The valid second-values. Caveat: Empty means all seconds are valid.
     */
    private TreeSet<Integer> seconds = new TreeSet<Integer>();
    /**
     * The valid minute-values. Caveat: Empty means all minutes are valid.
     */
    private TreeSet<Integer> minutes = new TreeSet<Integer>();
    /**
     * The valid hour-values. Cave: Empty means all hours are valid.
     */
    private TreeSet<Integer> hours = new TreeSet<Integer>();
    /**
     * The valid days of month-values. Cave: Empty means all days are valid.
     */
    private TreeSet<Integer> daysOfMonth = new TreeSet<Integer>();
    /**
     * The valid month-values. Cave: Empty means all months are valid.
     */
    private TreeSet<Integer> months = new TreeSet<Integer>();
    /**
     * The valid days of week-values. Cave: Empty means all days of week are
     * valid.
     */
    private TreeSet<Integer> daysOfWeek = new TreeSet<Integer>();

    /**
     * Parameterless constructor for use with serialization.
     */
    Schedule() {
    }

    /**
     * Constructor for creating a new schedule according to the parameters in
     * the given QuerySchedule 'schedule'.
     * 
     * @param schedule
     *            The EPCIS style schedule to be used for constructing this
     *            schedule.
     * @throws SubscriptionControlsException
     *             If invalid data is part of the Schedule.
     */
    public Schedule(final QuerySchedule schedule)
            throws SubscriptionControlsException {
        // Let's parse the QuerySchedule and
        // check it for validity when setting
        // the schedule values.
        if (schedule.getSecond() == null) {
            schedule.setSecond("");
        }
        if (schedule.getMinute() == null) {
            schedule.setMinute("");
        }
        if (schedule.getHour() == null) {
            schedule.setHour("");
        }
        if (schedule.getDayOfMonth() == null) {
            schedule.setDayOfMonth("");
        }
        if (schedule.getMonth() == null) {
            schedule.setMonth("");
        }
        if (schedule.getDayOfWeek() == null) {
            schedule.setDayOfWeek("");
        }
        String[] second = schedule.getSecond().split(",");
        String[] minute = schedule.getMinute().split(",");
        String[] hour = schedule.getHour().split(",");
        String[] dayOfMonth = schedule.getDayOfMonth().split(",");
        String[] month = schedule.getMonth().split(",");
        String[] dayOfWeek = schedule.getDayOfWeek().split(",");
        // Check and parse numbers and ranges
        Object[] sec = parseValuesAndRanges(second, "second");
        addSecondValues((Integer[]) sec[0]);
        addSecondRanges((Integer[][]) sec[1]);
        Object[] min = parseValuesAndRanges(minute, "minute");
        addMinuteValues((Integer[]) min[0]);
        addMinuteRanges((Integer[][]) min[1]);
        Object[] h = parseValuesAndRanges(hour, "hour");
        addHourValues((Integer[]) h[0]);
        addHourRanges((Integer[][]) h[1]);
        Object[] daysM = parseValuesAndRanges(dayOfMonth, "DayOfMonth");
        addDayOfMonthValues((Integer[]) daysM[0]);
        addDayOfMonthRanges((Integer[][]) daysM[1]);
        Object[] mon = parseValuesAndRanges(month, "month");
        addMonthValues((Integer[]) mon[0]);
        addMonthRanges((Integer[][]) mon[1]);
        Object[] daysW = parseValuesAndRanges(dayOfWeek, "DayOfWeek");
        addDayOfWeekValues((Integer[]) daysW[0]);
        addDayOfWeekRanges((Integer[][]) daysW[1]);

        // Check for invalid months/dayOfMonth combinations
        // ie. only 30.2 / 31.6 etc.
        if (!months.isEmpty()
                && (months.first() == months.last() && months.first() == 1 && (daysOfMonth.first() == 30 || daysOfMonth.first() == 31))) {
            throw new SubscriptionControlsException(
                    "Schedule invalid. Dates given are all impossible."
                            + "February doesn't have a 30th or 31st day.");
        }
        if (!months.isEmpty()
                && daysOfMonth.first() == 31
                && !months.contains(0) // Months w. 31 days are always ok
                && !months.contains(2) && !months.contains(4)
                && !months.contains(6) && !months.contains(7)
                && !months.contains(9) && !months.contains(11)) {
            throw new SubscriptionControlsException(
                    "Schedule invalid. Dates given are all impossible."
                            + "Given months don't have a 31st.");
        }

    }

    /**
     * Calculates the next scheduled time after now.
     * 
     * @return The next scheduled time after now.
     * @throws ImplementationException
     *             Almost any kind of error.
     */
    public GregorianCalendar nextScheduledTime() throws ImplementationException {
        GregorianCalendar cal = new GregorianCalendar();
        // We start at the next second
        // to avoid multiple results.
        cal.add(SECOND, 1);
        return nextScheduledTime(cal);
    }

    /**
     * Calculates the next scheduled time after the given 'time'.
     * 
     * @param time
     *            Time after which next scheduled time should be returned.
     * @return The next scheduled time after 'time'.
     * @throws ImplementationException
     *             Almost any kind of error.
     */
    public GregorianCalendar nextScheduledTime(final GregorianCalendar time)
            throws ImplementationException {
        /*
         * Algorithm idea: Start with biggest time unit (i.e. year) of the given
         * time. If unit value is specified to be valid (also implicitly by
         * omitting the value) in the schedule *and* there exists a valid
         * smaller unit for that time unit -> choose it as return value. Do so
         * recursively for all time units. Unfortunately month has to be special
         * cased because of 'dayOfWeek'. Attention: This is an ad hoc idea. If
         * you know a better algorithm speak up and/or implement it. Arthur.
         */
        GregorianCalendar nextSchedule = (GregorianCalendar) time.clone();
        // Look at year
        while (!monthMadeValid(nextSchedule)) {
            nextSchedule.roll(YEAR, true);
            setFieldsToMinimum(nextSchedule, MONTH);
        }
        return nextSchedule;
    }

    /**
     * Returns true if the month and all smaller units have been succesfully set
     * to valid values within the set year.
     * 
     * @param nextSchedule
     *            The current candidate for the result.
     * @return True if month and smaller units succesfully set to valid values.
     * @throws ImplementationException
     *             Almost any kind of error.
     */
    private boolean monthMadeValid(final GregorianCalendar nextSchedule)
            throws ImplementationException {
        if (!months.contains(nextSchedule.get(MONTH)) && !months.isEmpty()) {
            if (!setFieldToNextValidRoll(nextSchedule, MONTH, DAY_OF_MONTH)) {
                return false;
            }
        }
        // Now we're in a valid month, make smaller units
        // valid as well or go to next month.
        while (!dayMadeValid(nextSchedule)) {
            // No valid day for this month, try next month.
            if (!setFieldToNextValidRoll(nextSchedule, MONTH, DAY_OF_MONTH)) {
                return false;
            }
            // Reset all smaller units to min.
            if (!setFieldsToMinimum(nextSchedule, DAY_OF_MONTH)) {
                return false;
            }
        }
        return true;
    }

    /**
     * Returns true if the day and all smaller units have been succesfully set
     * to valid values within the set month.
     * 
     * @param nextSchedule
     *            The current candidate for the result.
     * @return True if day and smaller units succesfully set to valid values.
     * @throws ImplementationException
     *             Almost any kind of error.
     */
    private boolean dayMadeValid(final GregorianCalendar nextSchedule)
            throws ImplementationException {
        if (!daysOfMonth.contains(nextSchedule.get(DAY_OF_MONTH))
                && !daysOfMonth.isEmpty()) {
            if (!setFieldToNextValidRoll(nextSchedule, DAY_OF_MONTH,
                    HOUR_OF_DAY)) {
                return false;
            }
        }

        // Check and make this also a valid day of week.
        while (!daysOfWeek.contains(nextSchedule.get(DAY_OF_WEEK))
                && !daysOfWeek.isEmpty()) {
            if (!setFieldToNextValidRoll(nextSchedule, DAY_OF_MONTH,
                    HOUR_OF_DAY)) {
                return false;
            } else if (!daysOfWeek.contains(nextSchedule.get(DAY_OF_WEEK))) {
                dayMadeValid(nextSchedule);
            }
        }

        // Now we're in a valid day, make smaller units
        // valid as well or go to next day.
        while (!hourMadeValid(nextSchedule)) {
            // No valid hour for this day, try next day.
            if (!setFieldToNextValidRoll(nextSchedule, DAY_OF_MONTH,
                    HOUR_OF_DAY)) {
                return false;
            }
            // Reset all smaller units to min.
            if (!setFieldsToMinimum(nextSchedule, HOUR_OF_DAY)) {
                return false;
            }
        }
        return true;
    }

    /**
     * Returns true if the hour and all smaller units have been succesfully set
     * to valid values within the set day.
     * 
     * @param nextSchedule
     *            The current candidate for the result.
     * @return True if hour and smaller units succesfully set to valid values.
     * @throws ImplementationException
     *             Almost any error.
     */
    private boolean hourMadeValid(final GregorianCalendar nextSchedule)
            throws ImplementationException {
        if (!hours.contains(nextSchedule.get(HOUR_OF_DAY)) && !hours.isEmpty()) {
            if (!setFieldToNextValidRoll(nextSchedule, HOUR_OF_DAY, MINUTE)) {
                return false;
            }
        }

        // Now we're in a valid hour, make smaller units
        // valid as well or go to next hour.
        while (!minuteMadeValid(nextSchedule)) {
            // No valid minute for this hour, try next hour.
            if (!setFieldToNextValidRoll(nextSchedule, HOUR_OF_DAY, MINUTE)) {
                return false;
            }
            // Reset all smaller units to min.
            if (!setFieldsToMinimum(nextSchedule, MINUTE)) {
                return false;
            }
        }
        return true;
    }

    /**
     * Returns true if the minute and all smaller units have been succesfully
     * set to valid values within the set hour.
     * 
     * @param nextSchedule
     *            The current candidate for the result.
     * @return True if minute and smaller units succesfully set to valid values.
     * @throws ImplementationException
     *             Almost any error.
     */
    private boolean minuteMadeValid(final GregorianCalendar nextSchedule)
            throws ImplementationException {
        if (!minutes.contains(nextSchedule.get(MINUTE)) && !minutes.isEmpty()) {

            if (!setFieldToNextValidRoll(nextSchedule, MINUTE, SECOND)) {
                return false;
            }
        }

        // Now we're in a valid minute, make smaller units
        // valid as well or go to next minute.
        while (!secondMadeValid(nextSchedule)) {
            // No valid second for this minute, try next minute.

            if (!setFieldToNextValidRoll(nextSchedule, MINUTE, SECOND)) {
                return false;
            }
            // Reset all smaller units to min.
            if (!setFieldToMinimum(nextSchedule, SECOND)) {
                return false;
            }
        }
        return true;
    }

    /**
     * Returns true if the second have been succesfully set to valid values
     * within the set minute.
     * 
     * @param nextSchedule
     *            The current candidate for the result.
     * @return True if second succesfully set to valid values.
     * @throws ImplementationException
     *             Almost any error.
     */
    private boolean secondMadeValid(final GregorianCalendar nextSchedule)
            throws ImplementationException {
        if (!seconds.contains(nextSchedule.get(SECOND)) && !seconds.isEmpty()) {
            return setFieldToNextValid(nextSchedule, SECOND);
        }
        return true;
    }

    /**
     * Sets the field of a GregorianCalender to its next valid value, is defined
     * as the next possible value according to the calendar type used possibly
     * superseded by the defined values in the schedule we have. Returns whether
     * the new value has been set and is valid.
     * 
     * @param cal
     *            Calendar to adjust.
     * @param field
     *            Field to adjust.
     * @return Returns whether the new value has been set and is valid.
     * @throws ImplementationException
     *             Almost any error.
     */
    private Boolean setFieldToNextValid(final GregorianCalendar cal,
            final int field) throws ImplementationException {
        Integer next;
        TreeSet<Integer> vals = getVals(field);
        if (vals.isEmpty()) {
            next = cal.get(field) + 1;
        } else {
            try {
                // get next valid value which is bigger than current.
                next = vals.tailSet(cal.get(field) + 1).first();
            } catch (NoSuchElementException nse) {
                return false;
            }
        }
        if (next > cal.getActualMaximum(field)
                || next < cal.getActualMinimum(field)) {
            return false;
        }
        // All is well, set it to next.
        cal.set(field, next);
        return true;
    }

    /**
     * Sets the field of a GregorianCalender to its next valid value, but first
     * sets all smaller fields to their minima and rolls the datefield is
     * defined as the next possible value according to the calendar type used
     * possibly superseded by the defined values in the schedule we have.
     * Returns whether the new value has been set and is valid.
     * 
     * @param cal
     *            Calendar to adjust.
     * @param field
     *            Field to adjust. TODO: smallerField wouldn't be necessary.
     * @param smallerField
     *            Field from where on to minimize.
     * @return Returns whether the new value has been set and is valid.
     * @throws ImplementationException
     *             Almost any error.
     */
    private Boolean setFieldToNextValidRoll(final GregorianCalendar cal,
            final int field, final int smallerField)
            throws ImplementationException {
        cal.add(field, 1);
        setFieldsToMinimum(cal, smallerField);
        return setFieldToNextValid(cal, field);
    }

    /**
     * Sets the field of a GregorianCalender to its minimum, which is defined as
     * the minimal possible value according to the calendar type used possibly
     * superseded by the defined values in the schedule we have. Returns whether
     * the new value has been set and is valid.
     * 
     * @param cal
     *            Calendar to adjust.
     * @param field
     *            Field to adjust.
     * @return Returns whether the new value has been set and is valid.
     * @throws ImplementationException
     *             Almost any error.
     */
    private Boolean setFieldToMinimum(final GregorianCalendar cal,
            final int field) throws ImplementationException {
        Integer min;
        TreeSet<Integer> vals = getVals(field);
        if (vals.isEmpty()) {
            min = cal.getActualMinimum(field);
        } else {
            min = java.lang.Math.max(vals.first(), cal.getActualMinimum(field));
            if (min > cal.getActualMaximum(field)) {
                min = cal.getActualMaximum(field);
                if (!vals.contains(min) || min < cal.getActualMinimum(field)
                        || min > cal.getActualMaximum(field)) {
                    // System.out.println("Rarely we should see an invalid
                    // min.");
                    // System.out.println("Field is: " + field + " MinValid is:
                    // "
                    // + vals.first() + " minCal is: "
                    // + cal.getActualMinimum(field)
                    // + " maxCal is: " + cal.getActualMaximum(field));
                    return false;
                }
            }
        }
        cal.set(field, min);
        return true;
    }

    /**
     * Sets the field of a GregorianCalender and all smaller fields (not
     * WEEK_OF_DAY) to its minimum, which is defined as the minimal possible
     * value according to the calendar type used possibly superseded by the
     * defined values in the schedule we have. Returns whether the new values
     * have been set and are all valid.
     * 
     * @param cal
     *            Calendar instance to adjust.
     * @param largestField
     *            This field and smaller ones are reset
     * @return True if setting to min worked for all values.
     * @throws ImplementationException
     *             Various errors.
     */
    private Boolean setFieldsToMinimum(final GregorianCalendar cal,
            final int largestField) throws ImplementationException {
        Boolean result = true;
        switch (largestField) {
        case (MONTH):
            result = setFieldToMinimum(cal, MONTH) && result;
        case (DAY_OF_MONTH):
            result = setFieldToMinimum(cal, DAY_OF_MONTH) && result;
        case (HOUR_OF_DAY):
            result = setFieldToMinimum(cal, HOUR_OF_DAY) && result;
        case (MINUTE):
            result = setFieldToMinimum(cal, MINUTE) && result;
        case (SECOND):
            result = setFieldToMinimum(cal, SECOND) && result;
            break;
        default:
            throw new ImplementationException(
                    "Reached code we should never have reached: Ohb3umoo",
                    ImplementationExceptionSeverity.fromString("ERROR"), null,
                    null);
        }
        return result;
    }

    /**
     * Returns the numbers belonging to the 'field' value of a
     * GregorianCalendar.
     * 
     * @param field
     *            Field number of GregorianCalendar.
     * @return The schedule numbers belonging to this 'field'.
     * @throws ImplementationException
     *             In case of a access to an unknown field.
     */
    private TreeSet<Integer> getVals(final int field)
            throws ImplementationException {
        switch (field) {
        case (DAY_OF_WEEK):
            return daysOfWeek;
        case (MONTH):
            return months;
        case (DAY_OF_MONTH):
            return daysOfMonth;
        case (HOUR_OF_DAY):
            return hours;
        case (MINUTE):
            return minutes;
        case (SECOND):
            return seconds;
        default:
            throw new ImplementationException(
                    "Reached code we should never have reached: ieDahc5o",
                    ImplementationExceptionSeverity.fromString("ERROR"), null,
                    null);
        }
    }

    /**
     * Checks whether the 'values', which are either numbers or ranges, are
     * parseable and puts them into the return value.
     * 
     * @param values
     *            The numbers and ranges to be checked.
     * @throws SubscriptionControlsException
     *             In case there's some invalid data.
     * @return Returns an array where the first element is an array of ints with
     *         the number values and the second element is an array of arrays
     *         which denote the ranges.
     */
    private Object[] parseValuesAndRanges(final String[] values,
            final String parameter) throws SubscriptionControlsException {
        List<Integer> nums = new ArrayList<Integer>();
        List<Integer[]> ranges = new ArrayList<Integer[]>();
        for (String v : values) {
            try {
                if (v.startsWith("[")) {
                    // it's a range.
                    String[] r = v.substring(1, v.length() - 1).split("-");
                    ranges.add(new Integer[] {
                            Integer.decode(r[0]), Integer.decode(r[1]),
                    });
                } else if (!v.equals("")) {
                    // it's a number.
                    nums.add(Integer.decode(v));
                }
            } catch (Exception e) {
                String msg = "The value '" + v + "' for parameter '"
                        + parameter + "' is invalid in the query schedule.";
                LOG.info("USER ERROR: " + msg + e.getMessage());
                throw new SubscriptionControlsException(msg);
            }
        }
        return new Object[] {
                ((Integer[]) nums.toArray(new Integer[] {})),
                ((Integer[][]) ranges.toArray(new Integer[][] {}))
        };
    }

    /**
     * Checks whether all ranges lie within min and max and whether range[0] <=
     * range[1].
     * 
     * @param rangesArray
     *            Ranges to check.
     * @param min
     *            Minimal allowed value.
     * @param max
     *            Maximal allowed value.
     * @throws SubscriptionControlsException
     *             If illegal range encountered.
     */
    private void checkRanges(final Integer[][] rangesArray, final int min,
            final int max, final String parameter)
            throws SubscriptionControlsException {
        for (Integer[] r : rangesArray) {
            if (r[0] < min || r[1] > max || r[0] > r[1]) {
                throw new SubscriptionControlsException("The value for '"
                        + parameter
                        + "' is out of range in the query schedule.");
            }
        }
    }

    /**
     * Checks whether all values lie within min and max.
     * 
     * @param numsArray
     *            Numbers to check.
     * @param min
     *            Minimal allowed value.
     * @param max
     *            Maximal allowed value.
     * @throws SubscriptionControlsException
     *             If illegal range encountered.
     */
    private void checkNums(final Integer[] numsArray, final int min,
            final int max, final String parameter)
            throws SubscriptionControlsException {
        for (Integer n : numsArray) {
            if (n < min || n > max) {
                throw new SubscriptionControlsException("The value for '"
                        + parameter
                        + "' is out of range in the query schedule.");
            }
        }
    }

    /**
     * Adds all the values in the ranges to the given set.
     * 
     * @param ranges
     *            Ranges to add to set.
     * @param set
     *            Set to be enhanced with the values of the ranges.
     */
    private void addRangesToTreeSets(final Integer[][] ranges,
            final TreeSet<Integer> set) {
        for (Integer[] r : ranges) {
            for (Integer v = r[0]; v <= r[1]; v++) {
                set.add(v);
            }
        }
    }

    /**
     * Adds all the values in the array to the given set.
     * 
     * @param array
     *            Array to add to set.
     * @param set
     *            Set to be enhanced with the values of the array.
     */
    private void addValuesToTreeSets(final Integer[] array,
            final TreeSet<Integer> set) {
        for (Integer v : array) {
            set.add(v);
        }
    }

    /**
     * Adds day-of-month ranges.
     * 
     * @param dayOfMonthRanges
     *            The day-of-month ranges to add.
     * @throws SubscriptionControlsException
     *             If one of the ranges is invalid.
     */
    public void addDayOfMonthRanges(final Integer[][] dayOfMonthRanges)
            throws SubscriptionControlsException {
        checkRanges(dayOfMonthRanges, 1, 31, "DayOfMonth");
        addRangesToTreeSets(dayOfMonthRanges, daysOfMonth);
    }

    /**
     * Adds day-of-month values.
     * 
     * @param dayOfMonthValues
     *            The day-of-month values to add.
     * @throws SubscriptionControlsException
     *             If one of the values is invalid.
     */
    public void addDayOfMonthValues(final Integer[] dayOfMonthValues)
            throws SubscriptionControlsException {
        checkNums(dayOfMonthValues, 1, 31, "DayOfMonth");
        addValuesToTreeSets(dayOfMonthValues, daysOfMonth);
    }

    /**
     * Adds day-of-week ranges.
     * 
     * @param dayOfWeekRanges
     *            The day-of-week ranges to add.
     * @throws SubscriptionControlsException
     *             If one of the ranges is invalid.
     */
    public void addDayOfWeekRanges(final Integer[][] dayOfWeekRanges)
            throws SubscriptionControlsException {
        checkRanges(dayOfWeekRanges, 1, 7, "DayOfWeek");
        // Weekdays start one earlier in Java.
        TreeSet<Integer> temp = new TreeSet<Integer>();
        addRangesToTreeSets(dayOfWeekRanges, temp);
        for (Integer m : temp) {
            daysOfWeek.add((m % 7) + 1);
        }
    }

    /**
     * Adds day-of-week values.
     * 
     * @param dayOfWeekValues
     *            The day-of-week values to add.
     * @throws SubscriptionControlsException
     *             If one of the values is invalid.
     */
    public void addDayOfWeekValues(final Integer[] dayOfWeekValues)
            throws SubscriptionControlsException {
        checkNums(dayOfWeekValues, 1, 7, "DayOfWeek");
        // Weekdays start one earlier in Java.
        TreeSet<Integer> temp = new TreeSet<Integer>();
        addValuesToTreeSets(dayOfWeekValues, temp);
        for (Integer m : temp) {
            daysOfWeek.add((m % 7) + 1);
        }
    }

    /**
     * Adds hour ranges.
     * 
     * @param hourRanges
     *            The hour ranges to add.
     * @throws SubscriptionControlsException
     *             If one of the ranges is invalid.
     */
    public void addHourRanges(final Integer[][] hourRanges)
            throws SubscriptionControlsException {
        checkRanges(hourRanges, 0, 23, "hour");
        addRangesToTreeSets(hourRanges, hours);
    }

    /**
     * Adds hour values.
     * 
     * @param hourValues
     *            The hour values to add.
     * @throws SubscriptionControlsException
     *             If one of the values is invalid.
     */
    public void addHourValues(final Integer[] hourValues)
            throws SubscriptionControlsException {
        checkNums(hourValues, 0, 23, "hour");
        addValuesToTreeSets(hourValues, hours);
    }

    /**
     * Adds minute ranges.
     * 
     * @param minuteRanges
     *            The minute ranges to add.
     * @throws SubscriptionControlsException
     *             If one of the ranges is invalid.
     */
    public void addMinuteRanges(final Integer[][] minuteRanges)
            throws SubscriptionControlsException {
        checkRanges(minuteRanges, 0, 59, "minute");
        addRangesToTreeSets(minuteRanges, minutes);
    }

    /**
     * Adds minute values.
     * 
     * @param minuteValues
     *            The minute values to add.
     * @throws SubscriptionControlsException
     *             If one of the values is invalid.
     */
    public void addMinuteValues(final Integer[] minuteValues)
            throws SubscriptionControlsException {
        checkNums(minuteValues, 0, 59, "minute");
        addValuesToTreeSets(minuteValues, minutes);
    }

    /**
     * Adds month ranges.
     * 
     * @param monthRanges
     *            The month ranges to add.
     * @throws SubscriptionControlsException
     *             If one of the ranges is invalid.
     */
    public void addMonthRanges(final Integer[][] monthRanges)
            throws SubscriptionControlsException {
        checkRanges(monthRanges, 1, 12, "month");
        // Months start with 0 in Java.
        TreeSet<Integer> temp = new TreeSet<Integer>();
        addRangesToTreeSets(monthRanges, temp);
        for (Integer m : temp) {
            months.add(m - 1);
        }
    }

    /**
     * Adds month values.
     * 
     * @param monthValues
     *            The month values to add.
     * @throws SubscriptionControlsException
     *             If one of the values is invalid.
     */
    public void addMonthValues(final Integer[] monthValues)
            throws SubscriptionControlsException {
        checkNums(monthValues, 1, 12, "month");
        // Months start with 0 in Java.
        TreeSet<Integer> temp = new TreeSet<Integer>();
        addValuesToTreeSets(monthValues, temp);
        for (Integer m : temp) {
            months.add(m - 1);
        }
    }

    /**
     * Adds second ranges.
     * 
     * @param secondRanges
     *            The second ranges to add.
     * @throws SubscriptionControlsException
     *             If one of the ranges is invalid.
     */
    public void addSecondRanges(final Integer[][] secondRanges)
            throws SubscriptionControlsException {
        checkRanges(secondRanges, 0, 59, "second");
        addRangesToTreeSets(secondRanges, seconds);
    }

    /**
     * Adds second values.
     * 
     * @param secondValues
     *            The second values to add.
     * @throws SubscriptionControlsException
     *             If one of the values is invalid.
     */
    public void addSecondValues(final Integer[] secondValues)
            throws SubscriptionControlsException {
        checkNums(secondValues, 0, 59, "second");
        addValuesToTreeSets(secondValues, seconds);
    }

    public TreeSet<Integer> getDaysOfMonth() {
        return daysOfMonth;
    }

    public TreeSet<Integer> getDaysOfWeek() {
        return daysOfWeek;
    }

    public TreeSet<Integer> getHours() {
        return hours;
    }

    public TreeSet<Integer> getMinutes() {
        return minutes;
    }

    public TreeSet<Integer> getMonths() {
        return months;
    }

    public TreeSet<Integer> getSeconds() {
        return seconds;
    }
}
