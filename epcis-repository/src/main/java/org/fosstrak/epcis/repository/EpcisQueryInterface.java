/*
 * Copyright (c) 2006 ETH Zurich, Switzerland. All rights reserved. For copying
 * and distribution information, please see the file LICENSE.
 */
package org.accada.epcis.repository;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectInputStream;
import java.io.ObjectOutput;
import java.io.ObjectOutputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.rmi.RemoteException;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Set;

import org.accada.epcis.soapapi.ActionType;
import org.accada.epcis.soapapi.AggregationEventType;
import org.accada.epcis.soapapi.ArrayOfString;
import org.accada.epcis.soapapi.BusinessLocationType;
import org.accada.epcis.soapapi.BusinessTransactionType;
import org.accada.epcis.soapapi.DuplicateSubscriptionException;
import org.accada.epcis.soapapi.EPC;
import org.accada.epcis.soapapi.EPCISServicePortType;
import org.accada.epcis.soapapi.EmptyParms;
import org.accada.epcis.soapapi.EventListType;
import org.accada.epcis.soapapi.GetSubscriptionIDs;
import org.accada.epcis.soapapi.ImplementationException;
import org.accada.epcis.soapapi.ImplementationExceptionSeverity;
import org.accada.epcis.soapapi.InvalidURIException;
import org.accada.epcis.soapapi.NoSuchNameException;
import org.accada.epcis.soapapi.NoSuchSubscriptionException;
import org.accada.epcis.soapapi.ObjectEventType;
import org.accada.epcis.soapapi.Poll;
import org.accada.epcis.soapapi.QuantityEventType;
import org.accada.epcis.soapapi.QueryParam;
import org.accada.epcis.soapapi.QueryParameterException;
import org.accada.epcis.soapapi.QueryResults;
import org.accada.epcis.soapapi.QueryResultsBody;
import org.accada.epcis.soapapi.QueryTooLargeException;
import org.accada.epcis.soapapi.ReadPointType;
import org.accada.epcis.soapapi.Subscribe;
import org.accada.epcis.soapapi.SubscribeNotPermittedException;
import org.accada.epcis.soapapi.SubscriptionControls;
import org.accada.epcis.soapapi.SubscriptionControlsException;
import org.accada.epcis.soapapi.TransactionEventType;
import org.accada.epcis.soapapi.Unsubscribe;
import org.accada.epcis.soapapi.ValidationException;
import org.accada.epcis.soapapi.VoidHolder;
import org.accada.epcis.utils.TimeParser;
import org.apache.axis.MessageContext;
import org.apache.axis.message.MessageElement;
import org.apache.axis.types.URI;
import org.apache.log4j.Logger;

/**
 * EPCIS Query Interface implementation. Converts the invocations by axis to SQL
 * queries and returns the results to axis. Implementation is highly specific to
 * the database schema, so beware. The responses generated by the server stubs
 * are EPCIS standard compliant. However, the results will always be ordered
 * according to type, not in random order as the standard would allow. Our
 * *client*, however, will only work with our server, because it relies on the
 * fact that the answers are ordered. Using it with servers that do not order
 * the results may lead to arbitrary behaviour of our client (most likely lost
 * results).
 * 
 * @author David Gubler
 * @author Alain Remund
 * @author Arthur van Dorp
 * @author Marco Steybe
 */
public class EpcisQueryInterface implements EPCISServicePortType {

    private static final Logger LOG = Logger.getLogger(EpcisQueryInterface.class);

    /**
     * The version of the standard that this service is implementing.
     */
    private static final String STD_VERSION = "1.0";

    /**
     * The version of this service implementation.
     */
    private static final String VDR_VERSION = "http://www.accada.org/releases/0.2/";

    /**
     * The connection to the database.
     */
    private Connection dbconnection = null;

    /**
     * The database dependent identifier quotation sign.
     */
    private String delimiter;

    /**
     * Before returning the Results of the query, it checks if the set is too
     * large. This value can be set by Query-Parameters.
     */
    private int maxEventCount;

    /**
     * The names of all the implemented queries.
     */
    private final Set<String> queryNames = new HashSet<String>() {
        private static final long serialVersionUID = -3868728341409854448L;
        {
            // TODO: add SimpleMasterDataQuery once implemented.
            add("SimpleEventQuery");
        }
    };

    /**
     * Basic SQL query string for object events.
     */
    private String objectEventQueryBase = "SELECT DISTINCT "
            + "`event_ObjectEvent`.id, eventTime, recordTime, "
            + "eventTimeZoneOffset, action, "
            + "`voc_BizStep`.uri AS bizStep, "
            + "`voc_Disposition`.uri AS disposition, "
            + "`voc_ReadPoint`.uri AS readPoint, "
            + "`voc_BizLoc`.uri AS bizLocation "
            + "FROM `event_ObjectEvent` "
            + "LEFT JOIN `voc_BizStep` ON `event_ObjectEvent`.bizStep = `voc_BizStep`.id "
            + "LEFT JOIN `voc_Disposition` ON `event_ObjectEvent`.disposition = `voc_Disposition`.id "
            + "LEFT JOIN `voc_ReadPoint` ON `event_ObjectEvent`.readPoint = `voc_ReadPoint`.id "
            + "LEFT JOIN `voc_BizLoc` ON `event_ObjectEvent`.bizLocation = `voc_BizLoc`.id "
            + "LEFT JOIN `event_ObjectEvent_extensions` ON `event_ObjectEvent`.id = `event_ObjectEvent_extensions`.event_id "
            + "WHERE 1";

    /**
     * Basic SQL query string for aggregation events.
     */
    private String aggregationEventQueryBase = "SELECT DISTINCT "
            + "`event_AggregationEvent`.id, eventTime, recordTime, "
            + "eventTimeZoneOffset, parentID, action, "
            + "`voc_BizStep`.uri AS bizStep, "
            + "`voc_Disposition`.uri AS disposition, "
            + "`voc_ReadPoint`.uri AS readPoint, "
            + "`voc_BizLoc`.uri AS bizLocation "
            + "FROM `event_AggregationEvent` "
            + "LEFT JOIN `voc_BizStep` ON `event_AggregationEvent`.bizStep = `voc_BizStep`.id "
            + "LEFT JOIN `voc_Disposition` ON `event_AggregationEvent`.disposition  = `voc_Disposition`.id "
            + "LEFT JOIN `voc_ReadPoint` ON `event_AggregationEvent`.readPoint = `voc_ReadPoint`.id "
            + "LEFT JOIN `voc_BizLoc` ON `event_AggregationEvent`.bizLocation = `voc_BizLoc`.id "
            + "LEFT JOIN `event_AggregationEvent_extensions` ON `event_AggregationEvent`.id = `event_AggregationEvent_extensions`.event_id "
            + "WHERE 1 ";

    /**
     * Basic SQL query string for quantity events.
     */
    private String quantityEventQueryBase = "SELECT DISTINCT "
            + "`event_QuantityEvent`.id, eventTime, recordTime, eventTimeZoneOffset, "
            + "`voc_EPCClass`.uri AS epcClass, quantity, "
            + "`voc_BizStep`.uri AS bizStep, "
            + "`voc_Disposition`.uri AS disposition, "
            + "`voc_ReadPoint`.uri AS readPoint, "
            + "`voc_BizLoc`.uri AS bizLocation "
            + "FROM `event_QuantityEvent` "
            + "LEFT JOIN `voc_BizStep` ON `event_QuantityEvent`.bizStep = `voc_BizStep`.id "
            + "LEFT JOIN `voc_Disposition` ON `event_QuantityEvent`.disposition = `voc_Disposition`.id "
            + "LEFT JOIN `voc_ReadPoint` ON `event_QuantityEvent`.readPoint = `voc_ReadPoint`.id "
            + "LEFT JOIN `voc_BizLoc` ON `event_QuantityEvent`.bizLocation = `voc_BizLoc`.id "
            + "LEFT JOIN `voc_EPCClass` ON `event_QuantityEvent`.epcClass = `voc_EPCClass`.id "
            + "LEFT JOIN `event_QuantityEvent_extensions` ON `event_QuantityEvent`.id = `event_QuantityEvent_extensions`.event_id "
            + "WHERE 1 ";

    /**
     * Basic SQL query string for transaction events.
     */
    private String transactionEventQueryBase = "SELECT DISTINCT "
            + "`event_TransactionEvent`.id, eventTime, recordTime, "
            + "eventTimeZoneOffset, action, parentID, "
            + "`voc_BizStep`.uri AS bizStep, "
            + "`voc_Disposition`.uri AS disposition, "
            + "`voc_ReadPoint`.uri AS readPoint, "
            + "`voc_BizLoc`.uri AS bizLocation "
            + "FROM `event_TransactionEvent` "
            + "LEFT JOIN `voc_BizStep` ON `event_TransactionEvent`.bizStep = `voc_BizStep`.id "
            + "LEFT JOIN `voc_Disposition` ON `event_TransactionEvent`.disposition = `voc_Disposition`.id "
            + "LEFT JOIN `voc_ReadPoint` ON `event_TransactionEvent`.readPoint = `voc_ReadPoint`.id "
            + "LEFT JOIN `voc_BizLoc` ON `event_TransactionEvent`.bizLocation = `voc_BizLoc`.id "
            + "LEFT JOIN `event_TransactionEvent_extensions` ON `event_TransactionEvent`.id = `event_TransactionEvent_extensions`.event_id "
            + "WHERE 1 ";

    public EpcisQueryInterface() {
        LOG.info("EpcisQueryInterface invoked.");
        MessageContext msgContext = MessageContext.getCurrentContext();
        delimiter = (String) msgContext.getProperty("delimiter");
        dbconnection = (Connection) msgContext.getProperty("dbconnection");
    }

    /**
     * Returns whether subscriptionID already exists in DB.
     * 
     * @param subscrId
     *            The id to be looked up.
     * @return <code>true</code> if subscriptionID already exists in DB,
     *         <code>false</code> otherwise.
     * @throws SQLException
     *             If a problem with the database occured.
     * @throws ImplementationException
     *             If a problem with the EPCIS implementation occured.
     */
    private boolean fetchExistsSubscriptionId(final String subscrId)
            throws SQLException, ImplementationException {
        String query = "SELECT EXISTS(SELECT subscriptionid FROM subscription WHERE subscriptionid = (?))";
        PreparedStatement pstmt = dbconnection.prepareStatement(query);
        pstmt.setString(1, subscrId);
        LOG.debug("QUERY: " + query);
        LOG.debug("       query param 1: " + subscrId);

        ResultSet rs = pstmt.executeQuery();
        rs.first();
        Boolean result = rs.getBoolean(1);
        rs.close();

        return result.booleanValue();
    }

    /**
     * Returns all EPCs associated to a certain event_id.
     * 
     * @param tableName
     *            The SQL name of the table to be searched
     * @param eventId
     *            is typically an 64bit integer. We use string here to avoid
     *            java vs. SQL type problems.
     * @return EPCs beloning to event_id
     * @throws SQLException
     *             If an error with the database occured.
     */
    private EPC[] fetchEPCs(final String tableName, final int eventId)
            throws SQLException {
        String query = "SELECT DISTINCT epc FROM " + delimiter + tableName
                + delimiter + " WHERE " + delimiter + "event_id" + delimiter
                + " = " + eventId;
        LOG.debug("QUERY: " + query);
        Statement stmt = dbconnection.createStatement();

        ResultSet rs = stmt.executeQuery(query);
        List<EPC> epcList = new ArrayList<EPC>();
        while (rs.next()) {
            EPC epc = new EPC(rs.getString("epc"));
            epcList.add(epc);
        }

        EPC[] epcs = new EPC[epcList.size()];
        epcs = epcList.toArray(epcs);
        return epcs;
    }

    /**
     * Retreives all MessageElement, i.e. all fieldname extensions for the given
     * event.
     * 
     * @param tableName
     *            The name of the table with the field extensions of the event.
     * @param eventId
     *            The ID of the event
     * @return All MessageElement (fieldname extensions) associated with the
     *         given eventId.
     * @throws SQLException
     *             If an error with the database occured.
     */
    private MessageElement[] fetchMessageElements(final String tableName,
            final int eventId) throws SQLException {
        String query = "SELECT * FROM " + delimiter + tableName + delimiter
                + " WHERE " + delimiter + "event_id" + delimiter + " = "
                + eventId;
        LOG.debug("QUERY: " + query);
        Statement stmt = dbconnection.createStatement();

        ResultSet rs = stmt.executeQuery(query);
        List<MessageElement> meList = new ArrayList<MessageElement>();
        while (rs.next()) {
            String fieldname = rs.getString("fieldname");
            String[] parts = fieldname.split("#");
            if (parts.length != 2) {
                throw new SQLException("Column 'fieldname' in table '"
                        + tableName + "' has invalid format: " + fieldname);
            }
            String namespace = parts[0];
            String localPart = parts[1];
            String prefix = rs.getString("prefix");
            String value = rs.getString("intValue");
            if (value == null) {
                value = rs.getString("floatValue");
            }
            if (value == null) {
                value = rs.getString("strValue");
            }
            if (value == null) {
                value = rs.getString("dateValue");
            }
            if (value == null) {
                throw new SQLException("All value columns in '" + tableName
                        + "' are null.");
            }
            MessageElement me = new MessageElement(localPart, prefix, namespace);
            me.setValue(value);
            LOG.debug("message element resolved to " + me.toString());
            meList.add(me);
        }
        MessageElement[] any = new MessageElement[meList.size()];
        any = meList.toArray(any);
        return any;
    }

    /**
     * Returns all bizTransactions associated to a certain event_id.
     * 
     * @param tableName
     *            The SQL name of the table to be searched.
     * @param eventId
     *            Typically an 64bit integer to identify the event.
     * @return bizTransactions associated to event_id
     * @throws SQLException
     *             DB problem.
     * @throws ImplementationException
     *             Several problems get matched to this exception.
     */
    private BusinessTransactionType[] fetchBizTransactions(
            final String tableName, final int eventId) throws SQLException,
            ImplementationException {
        String query = "SELECT DISTINCT "
                + "`voc_BizTrans`.uri, `voc_BizTransType`.uri AS `typeuri`"
                + "FROM ((`BizTransaction` JOIN `"
                + tableName
                + "` ON `BizTransaction`.id = `"
                + tableName
                + "`.`bizTrans_id`)"
                + "JOIN `voc_BizTrans` ON `BizTransaction`.`bizTrans` = `voc_BizTrans`.id)"
                + " LEFT OUTER JOIN `voc_BizTransType` ON `BizTransaction`.`type` = `voc_BizTransType`.id"
                + " WHERE `" + tableName + "`.event_id = " + eventId;
        LOG.debug("QUERY: " + query);
        Statement stmt = dbconnection.createStatement();

        ResultSet rs = stmt.executeQuery(query.replaceAll("`", delimiter));
        List<BusinessTransactionType> bizTransList = new ArrayList<BusinessTransactionType>();
        while (rs.next()) {
            String uriString = null;
            uriString = rs.getString("uri");
            URI uri = stringToUri(uriString);
            BusinessTransactionType btrans = new BusinessTransactionType(uri);
            uriString = rs.getString("typeuri");
            if (uriString != null) {
                uri = stringToUri(uriString);
                btrans.setType(uri);
            }
            bizTransList.add(btrans);
        }

        BusinessTransactionType[] bizTrans = new BusinessTransactionType[bizTransList.size()];
        bizTrans = bizTransList.toArray(bizTrans);
        return bizTrans;
    }

    /**
     * Convert a string to a URI. Exceptions are caught and a meaningful
     * ImplementationException is thrown instead. This method works on axis
     * URIs, not Java URIs. Make sure you have the right imports.
     * 
     * @param uriString
     *            String to convert to URI
     * @return URI
     * @throws ImplementationException
     *             Thrown when string not in URI format.
     */
    private URI stringToUri(final String uriString)
            throws ImplementationException {
        try {
            if (uriString == null) {
                return null;
            }
            URI uri = new URI(uriString);
            return uri;
        } catch (URI.MalformedURIException e) {
            String msg = "Malformed URI value: " + uriString;
            LOG.error(msg, e);
            ImplementationException iex = new ImplementationException();
            iex.setReason(msg);
            iex.setStackTrace(e.getStackTrace());
            iex.setSeverity(ImplementationExceptionSeverity.ERROR);
            throw iex;
        }
    }

    /**
     * Executes an SQL query and returns an array of ObjectEventType.
     * 
     * @param objectEventQuery
     *            Query. Supposed to be created by createEventQuery.
     * @return ObjectEventType[]
     * @throws SQLException
     *             Problem on db backend. The Query must return ObjectEvents,
     *             otherwise this leads to an SQLException as well. is thrown.
     * @throws ImplementationException
     *             Problem with data or on implementation side. (i.e. uri value
     *             in DB is actually not an uri)
     */
    private ObjectEventType[] runObjectEventQuery(
            final PreparedStatement objectEventQuery) throws SQLException,
            ImplementationException {
        if (objectEventQuery == null) {
            return null;
        }

        // Calendar needed for converting timestamps
        Calendar cal = Calendar.getInstance();

        // run the query and get all ObjectEvents
        ResultSet rs = objectEventQuery.executeQuery();

        List<ObjectEventType> objectEventList = new ArrayList<ObjectEventType>();
        while (rs.next()) {
            ObjectEventType objectEvent = new ObjectEventType();
            int eventId = rs.getInt("id");

            // set EventTime, RecordTime, and EventTimezoneOffset
            cal.setTime(rs.getTimestamp("eventTime"));
            objectEvent.setEventTime((Calendar) cal.clone());
            cal.setTime(rs.getTimestamp("recordTime"));
            objectEvent.setRecordTime((Calendar) cal.clone());
            objectEvent.setEventTimeZoneOffset(rs.getString("eventTimeZoneOffset"));

            // set action
            ActionType action = ActionType.fromString(rs.getString("action"));
            objectEvent.setAction(action);

            // set all URIs
            objectEvent.setBizStep(stringToUri(rs.getString("bizStep")));
            objectEvent.setDisposition(stringToUri(rs.getString("disposition")));
            if (rs.getString("readPoint") != null) {
                ReadPointType rp = new ReadPointType();
                rp.setId(stringToUri(rs.getString("readPoint")));
                objectEvent.setReadPoint(rp);
            }
            if (rs.getString("bizLocation") != null) {
                BusinessLocationType blt = new BusinessLocationType();
                blt.setId(stringToUri(rs.getString("bizLocation")));
                objectEvent.setBizLocation(blt);
            }

            // set business transactions
            BusinessTransactionType[] btt = fetchBizTransactions(
                    "event_ObjectEvent_bizTrans", eventId);
            objectEvent.setBizTransactionList(btt);

            // set EPCs
            EPC[] epcs = fetchEPCs("event_ObjectEvent_EPCs", eventId);
            objectEvent.setEpcList(epcs);

            // set field extensions
            MessageElement[] any = fetchMessageElements(
                    "event_ObjectEvent_extensions", eventId);
            objectEvent.set_any(any);

            objectEventList.add(objectEvent);
        }
        rs.close();
        ObjectEventType[] objectEvents = {};
        objectEvents = objectEventList.toArray(objectEvents);

        return objectEvents;
    }

    /**
     * Executes a SQL Query and returns an array of AggregationEventType.
     * 
     * @param aggregationEventQuery
     *            The Query is supposed to be created by createEventQuery(...,
     *            "AggregationEvent").
     * @return AggregationEventType[]
     * @throws SQLException
     *             Must return AggregationEvents, otherwise an SQLException is
     *             thrown.
     * @throws ImplementationException
     *             May throw ImplementationException for various reasons (i.e.
     *             uri value in DB is actually not an uri)
     */
    private AggregationEventType[] runAggregationEventQuery(
            final PreparedStatement aggregationEventQuery) throws SQLException,
            ImplementationException {
        if (aggregationEventQuery == null) {
            return null;
        }

        // Calendar needed for converting timestamps
        Calendar cal = Calendar.getInstance();

        // run the query and get all AggregationEvents
        ResultSet rs = aggregationEventQuery.executeQuery();

        List<AggregationEventType> aggrEventList = new ArrayList<AggregationEventType>();
        while (rs.next()) {
            AggregationEventType aggrEvent = new AggregationEventType();
            int eventId = rs.getInt("id");

            // set EventTime, RecordTime, and EventTimezoneOffset
            cal.setTime(rs.getTimestamp("eventTime"));
            aggrEvent.setEventTime((Calendar) cal.clone());
            cal.setTime(rs.getTimestamp("recordTime"));
            aggrEvent.setRecordTime((Calendar) cal.clone());
            aggrEvent.setEventTimeZoneOffset(rs.getString("eventTimeZoneOffset"));

            // set action
            ActionType action = ActionType.fromString(rs.getString("action"));
            aggrEvent.setAction(action);

            // set all URIs
            aggrEvent.setParentID(stringToUri(rs.getString("parentID")));
            aggrEvent.setBizStep(stringToUri(rs.getString("bizStep")));
            aggrEvent.setDisposition(stringToUri(rs.getString("disposition")));
            if (rs.getString("readPoint") != null) {
                ReadPointType rpt = new ReadPointType();
                rpt.setId(stringToUri(rs.getString("readPoint")));
                aggrEvent.setReadPoint(rpt);
            }
            if (rs.getString("bizLocation") != null) {
                BusinessLocationType blt = new BusinessLocationType();
                blt.setId(stringToUri(rs.getString("bizLocation")));
                aggrEvent.setBizLocation(blt);
            }

            // set business transactions
            BusinessTransactionType[] bizTrans = fetchBizTransactions(
                    "event_AggregationEvent_bizTrans", eventId);
            aggrEvent.setBizTransactionList(bizTrans);

            // set associated EPCs
            EPC[] epcs = fetchEPCs("event_AggregationEvent_EPCs", eventId);
            aggrEvent.setChildEPCs(epcs);

            // TODO: marco: fetchMessageElements()

            aggrEventList.add(aggrEvent);
        }
        rs.close();
        AggregationEventType[] aggrEvents = new AggregationEventType[aggrEventList.size()];
        aggrEvents = aggrEventList.toArray(aggrEvents);
        return aggrEvents;
    }

    /**
     * Executes a SQL Query and returns an array of QuantityEventType.
     * 
     * @param quantityEventQuery
     *            The Query is supposed to be created by createEventQuery(...,
     *            "QuantityEvent").
     * @return QuantityEventType[]
     * @throws SQLException
     *             The Query must return QuantityEvents, otherwise an
     *             SQLException is thrown.
     * @throws ImplementationException
     *             May throw ImplementationException for various reasons (i.e.
     *             uri value in DB is actually not an uri)
     */
    private QuantityEventType[] runQuantityEventQuery(
            final PreparedStatement quantityEventQuery) throws SQLException,
            ImplementationException {
        if (quantityEventQuery == null) {
            return null;
        }

        // Calendar needed for converting timestamps
        Calendar cal = Calendar.getInstance();

        // run the query and get all QuantityEvents
        ResultSet rs = quantityEventQuery.executeQuery();

        List<QuantityEventType> quantEventList = new ArrayList<QuantityEventType>();
        while (rs.next()) {
            QuantityEventType quantEvent = new QuantityEventType();
            int eventId = rs.getInt("id");

            // set EventTime, RecordTime, and EventTimezoneOffset
            cal.setTime(rs.getTimestamp("eventTime"));
            quantEvent.setEventTime((Calendar) cal.clone());
            cal.setTime(rs.getTimestamp("recordTime"));
            quantEvent.setRecordTime((Calendar) cal.clone());
            quantEvent.setEventTimeZoneOffset(rs.getString("eventTimeZoneOffset"));

            // set EPCClass
            quantEvent.setEpcClass(stringToUri(rs.getString("epcClass")));

            // set quantity
            quantEvent.setQuantity(rs.getInt("quantity"));

            // set all URIs
            quantEvent.setBizStep(stringToUri(rs.getString("bizStep")));
            quantEvent.setDisposition(stringToUri(rs.getString("disposition")));
            if (rs.getString("readPoint") != null) {
                ReadPointType rpt = new ReadPointType();
                rpt.setId(stringToUri(rs.getString("readPoint")));
                quantEvent.setReadPoint(rpt);
            }
            if (rs.getString("bizLocation") != null) {
                BusinessLocationType blt = new BusinessLocationType();
                blt.setId(stringToUri(rs.getString("bizLocation")));
                quantEvent.setBizLocation(blt);
            }

            // set business transactions
            BusinessTransactionType[] bizTrans = fetchBizTransactions(
                    "event_QuantityEvent_bizTrans", eventId);
            quantEvent.setBizTransactionList(bizTrans);

            quantEventList.add(quantEvent);
        }
        rs.close();

        QuantityEventType[] quantEvents = new QuantityEventType[quantEventList.size()];
        quantEvents = quantEventList.toArray(quantEvents);
        return quantEvents;
    }

    /**
     * Executes a SQL Query and returns an array of TransactionEventType.
     * 
     * @param transactionEventQuery
     *            The Query is supposed to be created by createEventQuery(...,
     *            "TransactionEvent").
     * @return AggregationEventType[]
     * @throws SQLException
     *             The Query must return TransactionEvents, otherwise an
     *             SQLException is thrown.
     * @throws ImplementationException
     *             May throw ImplementationException for various reasons (i.e.
     *             uri value in DB is actually not an uri)
     */
    private TransactionEventType[] runTransactionEventQuery(
            final PreparedStatement transactionEventQuery) throws SQLException,
            ImplementationException {
        if (transactionEventQuery == null) {
            return null;
        }

        // Calendar needed for converting timestamps
        Calendar cal = Calendar.getInstance();

        // run the query and get all TransactionEvents
        ResultSet rs = transactionEventQuery.executeQuery();

        List<TransactionEventType> transEventList = new ArrayList<TransactionEventType>();
        while (rs.next()) {
            TransactionEventType transEvent = new TransactionEventType();
            int eventId = rs.getInt("id");

            // set EventTime, RecordTime, and EventTimezoneOffset
            cal.setTime(rs.getTimestamp("eventTime"));
            transEvent.setEventTime((Calendar) cal.clone());
            cal.setTime(rs.getTimestamp("recordTime"));
            transEvent.setRecordTime((Calendar) cal.clone());
            transEvent.setEventTimeZoneOffset(rs.getString("eventTimeZoneOffset"));

            // set action
            ActionType action = ActionType.fromString(rs.getString("action"));
            transEvent.setAction(action);

            // set all URIs
            transEvent.setParentID(stringToUri(rs.getString("parentID")));
            transEvent.setBizStep(stringToUri(rs.getString("bizStep")));
            transEvent.setDisposition(stringToUri(rs.getString("disposition")));
            if (rs.getString("readPoint") != null) {
                ReadPointType rpt = new ReadPointType();
                rpt.setId(stringToUri(rs.getString("readPoint")));
                transEvent.setReadPoint(rpt);
            }
            if (rs.getString("bizLocation") != null) {
                BusinessLocationType blt = new BusinessLocationType();
                blt.setId(stringToUri(rs.getString("bizLocation")));
                transEvent.setBizLocation(blt);
            }

            // set business transactions
            BusinessTransactionType[] bizTrans = fetchBizTransactions(
                    "event_TransactionEvent_bizTrans", eventId);
            transEvent.setBizTransactionList(bizTrans);

            // set associated EPCs
            EPC[] epcs = fetchEPCs("event_TransactionEvent_EPCs", eventId);
            transEvent.setEpcList(epcs);

            transEventList.add(transEvent);
        }
        rs.close();

        TransactionEventType[] transEvents = new TransactionEventType[transEventList.size()];
        transEvents = transEventList.toArray(transEvents);
        return transEvents;
    }

    /**
     * Transforms an array of strings into sql IN (...) notation. Takes the
     * string array, the query string and the argument vector This function is
     * designed to be used with PreparedStatement
     * 
     * @param strings
     *            Array of strings to be added to sql IN (...) expression.
     * @param query
     *            The query which will be appended with the appropriate amounts
     *            of question marks for the parameters.
     * @param queryArgs
     *            The queryArgs vector which will take the additional query
     *            parameters specified in 'strings'.
     */
    private void stringArrayToSQL(final String[] strings,
            final StringBuffer query, final List<String> queryArgs) {
        int j = 0;
        while (j < strings.length - 1) {
            query.append("?,");
            queryArgs.add(strings[j]);
            j++;
        }
        if (strings.length > 0) {
            query.append("?");
            queryArgs.add(strings[j]);
        }
    }

    /**
     * Create an SQL query string from a list of Query Parameters.
     * 
     * @param queryParams
     *            The query parameters.
     * @param eventType
     *            Has to be one of the four basic event types "ObjectEvent",
     *            "AggregationEvent", "QuantityEvent", "TransactionEvent".
     * @return The prepared sql statement.
     * @throws SQLException
     *             Whenever something goes wrong when querying the db.
     * @throws QueryParameterException
     *             If one of the given QueryParam is invalid.
     * @throws ImplementationException
     */
    private PreparedStatement createEventQuery(final QueryParam[] queryParams,
            final String eventType) throws SQLException,
            QueryParameterException, ImplementationException {

        StringBuffer query;
        if (eventType.equals("ObjectEvent")) {
            query = new StringBuffer(objectEventQueryBase);
        } else if (eventType.equals("AggregationEvent")) {
            query = new StringBuffer(aggregationEventQueryBase);
        } else if (eventType.equals("QuantityEvent")) {
            query = new StringBuffer(quantityEventQueryBase);
        } else if (eventType.equals("TransactionEvent")) {
            query = new StringBuffer(transactionEventQueryBase);
        } else {
            ImplementationException iex = new ImplementationException();
            String msg = "Invalid event type encountered: " + eventType;
            LOG.error(msg);
            iex.setReason(msg);
            iex.setSeverity(ImplementationExceptionSeverity.ERROR);
            throw iex;
        }

        String orderBy = "";
        String orderDirection = "";
        int limit = -1;
        int maxEvent = -1;
        List<String> params = new LinkedList<String>();
        List<String> queryArgs = new ArrayList<String>();

        for (int i = 0; i < queryParams.length; i++) {
            String paramName = queryParams[i].getName();
            Object paramValue = queryParams[i].getValue();

            // check if this parameter has already been provided
            if (params.contains(paramName)) {
                String msg = "Two or more inputs are provided for the same parameter '"
                        + paramName + "'.";
                LOG.info("USER ERROR: " + msg);
                throw new QueryParameterException(msg);
            } else {
                params.add(paramName);
            }

            try {
                if (paramName.equals("eventType")) {
                    // search for the eventType in the list of arguments.
                    // If it does not appear, this eventType is not asked for
                    // and we return null as the query string
                    String[] arglist = ((ArrayOfString) paramValue).getString();
                    int j = 0;
                    while (arglist != null && (j < arglist.length)
                            && (!arglist[j].equals(eventType))) {
                        j++;
                    }
                    if (arglist != null && arglist.length > 0
                            && j == arglist.length) {
                        return null;
                    }
                } else if (paramName.equals("GE_eventTime")) {
                    query.append(" AND (eventTime >= ?) ");
                    Calendar cal = (Calendar) paramValue;
                    Timestamp ts = new Timestamp(cal.getTimeInMillis());
                    queryArgs.add(ts.toString());

                } else if (paramName.equals("LT_eventTime")) {
                    query.append(" AND (eventTime < ?) ");
                    Calendar cal = (Calendar) paramValue;
                    Timestamp ts = new Timestamp(cal.getTimeInMillis());
                    queryArgs.add(ts.toString());

                } else if (paramName.equals("GE_recordTime")) {
                    query.append(" AND (recordTime >= ?) ");
                    Calendar cal = (Calendar) paramValue;
                    Timestamp ts = new Timestamp(cal.getTimeInMillis());
                    queryArgs.add(ts.toString());

                } else if (paramName.equals("LT_recordTime")) {
                    query.append(" AND (recordTime < ?) ");
                    Calendar cal = (Calendar) paramValue;
                    Timestamp ts = new Timestamp(cal.getTimeInMillis());
                    queryArgs.add(ts.toString());

                } else if (paramName.equals("EQ_action")) {
                    if (!eventType.equals("QuantityEvent")) {
                        String[] actions = ((ArrayOfString) paramValue).getString();
                        checkActionValues(actions);
                        query.append(" AND (action IN (");
                        stringArrayToSQL(actions, query, queryArgs);
                        query.append(")) ");
                    } else {
                        query.append(" AND 0 ");
                    }

                } else if (paramName.equals("EQ_bizStep")) {
                    query.append(" AND (`voc_BizStep`.uri IN (");
                    stringArrayToSQL(((ArrayOfString) paramValue).getString(),
                            query, queryArgs);
                    query.append(")) ");

                } else if (paramName.equals("EQ_disposition")) {
                    query.append(" AND (`voc_Disposition`.uri IN (");
                    stringArrayToSQL(((ArrayOfString) paramValue).getString(),
                            query, queryArgs);
                    query.append(")) ");

                } else if (paramName.equals("EQ_readPoint")) {
                    query.append(" AND (`voc_ReadPoint`.uri IN (");
                    stringArrayToSQL(((ArrayOfString) paramValue).getString(),
                            query, queryArgs);
                    query.append(")) ");

                } else if (paramName.equals("WD_readPoint")) {
                    // the % allows any possible ending, which should implement
                    // the semantics of "With Descendant"
                    String[] readPoints = ((ArrayOfString) paramValue).getString();
                    query.append(" AND `voc_ReadPoint`.uri IS NOT NULL AND (");
                    int j = 0;
                    while (j < readPoints.length - 1) {
                        query.append("`voc_ReadPoint`.uri LIKE ? OR ");
                        queryArgs.add(readPoints[j] + "%");
                        j++;
                    }
                    if (readPoints.length > 0) {
                        query.append("`voc_ReadPoint`.uri LIKE ?");
                        queryArgs.add(readPoints[j] + "%");
                    }
                    query.append(") ");

                } else if (paramName.equals("EQ_bizLocation")) {
                    query.append(" AND (`voc_BizLoc`.uri IN (");
                    stringArrayToSQL(((ArrayOfString) paramValue).getString(),
                            query, queryArgs);
                    query.append(")) ");

                } else if (paramName.equals("WD_bizLocation")) {
                    String[] bizLocations = null;
                    try {
                        bizLocations = ((ArrayOfString) paramValue).getString();
                    } catch (ClassCastException e) {
                        // we have the URI directly (no ArrayOfString wrapper)
                        bizLocations = new String[1];
                        bizLocations[0] = paramValue.toString();
                    }
                    for (int j = 0; j < bizLocations.length; j++) {
                        bizLocations[j] = bizLocations[j] + "%";
                    }
                    query.append(" AND (");
                    int j = 0;
                    while (j < bizLocations.length - 1) {
                        query.append("`voc_BizLoc`.uri LIKE ? OR ");
                        queryArgs.add(bizLocations[j]);
                        j++;
                    }
                    if (bizLocations.length > 0) {
                        query.append("`voc_BizLoc`.uri LIKE ?");
                        queryArgs.add(bizLocations[j]);
                    }
                    query.append(") ");

                } else if (paramName.startsWith("EQ_bizTransaction_")) {
                    // this query is subdivided into several subqueries

                    // subquery for selecting IDs from voc_BizTransType
                    // type extracted from parameter name
                    String type = paramName.substring(18);
                    String vocBizTransTypeId = "SELECT id FROM `voc_BizTransType` WHERE uri=\""
                            + type + "\"";

                    // subquery for selecting IDs from voc_BizTrans
                    StringBuffer temp = new StringBuffer();
                    temp.append("(SELECT id AS vocBizTransId FROM `voc_BizTrans` WHERE `voc_BizTrans`.uri IN (");
                    String[] strings = ((ArrayOfString) paramValue).getString();
                    int j = 0;
                    while (j < strings.length - 1) {
                        temp.append("\"" + strings[j] + "\",");
                        j++;
                    }
                    if (strings.length > 0) {
                        temp.append("\"" + strings[j] + "\"");
                    }
                    temp.append(")) AS SelectedVocBizTrans");
                    String vocBizTransIds = temp.toString();

                    // subquery for selecting IDs from BizTransaction
                    String selectedBizTrans = "(SELECT id AS bizTransId, bizTrans FROM `BizTransaction` bt WHERE bt.type=("
                            + vocBizTransTypeId + ")) AS SelectedBizTrans";
                    String bizTransId = "SELECT bizTransId FROM "
                            + vocBizTransIds
                            + " INNER JOIN "
                            + selectedBizTrans
                            + " ON SelectedBizTrans.bizTrans=SelectedVocBizTrans.vocBizTransId";

                    query.append(" AND (`event_" + eventType + "`.id IN (");
                    query.append("SELECT event_id AS id ");
                    query.append("FROM `event_" + eventType + "_bizTrans` ");
                    query.append("INNER JOIN (");
                    query.append(bizTransId);
                    query.append(") AS BizTransIds ");
                    query.append("ON BizTransIds.bizTransId=`event_"
                            + eventType + "_bizTrans`.bizTrans_id");
                    query.append("))");

                } else if (paramName.equals("MATCH_epc")) {
                    if (!eventType.equals("QuantityEvent")) {
                        String[] values = ((ArrayOfString) paramValue).getString();
                        if (values.length > 0) {
                            query.append(" AND (`event_" + eventType
                                    + "`.id IN (");
                            String val = values[0].replace("*", "%");
                            query.append("SELECT event_id FROM `event_"
                                    + eventType + "_EPCs` WHERE epc LIKE '"
                                    + val + "'");
                            for (int j = 1; j < values.length; j++) {
                                val = values[j].replace("*", "%");
                                query.append(" OR epc LIKE '" + val + "'");
                            }
                            query.append("))");
                        }
                    } else {
                        query.append(" AND 0 ");
                    }

                } else if (paramName.equals("MATCH_parentID")) {
                    if (eventType.equals("AggregationEvent")
                            || eventType.equals("TransactionEvent")) {
                        query.append(" AND (parentID IN (");
                        stringArrayToSQL(
                                ((ArrayOfString) paramValue).getString(),
                                query, queryArgs);
                        query.append("))");
                    } else {
                        query.append(" AND 0 ");
                    }

                } else if (paramName.equals("MATCH_childEPC")) {
                    if (eventType.equals("AggregationEvent")) {
                        query.append(" AND (`event_AggregationEvent`.id IN (");
                        query.append("SELECT event_id FROM `event_AggregationEvent_EPCs` WHERE epc IN (");
                        stringArrayToSQL(
                                ((ArrayOfString) paramValue).getString(),
                                query, queryArgs);
                        query.append(")))");
                    } else {
                        query.append(" AND 0 ");
                    }

                } else if (paramName.equals("MATCH_epcClass")) {
                    if (eventType.equals("QuantityEvent")) {
                        query.append(" AND (epcClass IN (");
                        query.append("SELECT id FROM `voc_EPCClass` WHERE uri IN (");
                        stringArrayToSQL(
                                ((ArrayOfString) paramValue).getString(),
                                query, queryArgs);
                        query.append(")))");
                    } else {
                        query.append(" AND 0 ");
                    }

                } else if (paramName.equals("EQ_quantity")) {
                    if (eventType.equals("QuantityEvent")) {
                        query.append(" AND (quantity = ?) ");
                        queryArgs.add(((Integer) paramValue).toString());
                    } else {
                        query.append(" AND 0 ");
                    }

                } else if (paramName.equals("GT_quantity")) {
                    if (eventType.equals("QuantityEvent")) {
                        query.append(" AND (quantity > ?) ");
                        queryArgs.add(((Integer) paramValue).toString());
                    } else {
                        query.append(" AND 0 ");
                    }

                } else if (paramName.equals("GE_quantity")) {
                    if (eventType.equals("QuantityEvent")) {
                        query.append(" AND (quantity >= ?) ");
                        queryArgs.add(((Integer) paramValue).toString());
                    } else {
                        query.append(" AND 0 ");
                    }

                } else if (paramName.equals("LT_quantity")) {
                    if (eventType.equals("QuantityEvent")) {
                        query.append(" AND (quantity < ?) ");
                        queryArgs.add(((Integer) paramValue).toString());
                    } else {
                        query.append(" AND 0 ");
                    }

                } else if (paramName.equals("LE_quantity")) {
                    if (eventType.equals("QuantityEvent")) {
                        query.append(" AND (quantity <= ?) ");
                        queryArgs.add(((Integer) paramValue).toString());
                    } else {
                        query.append(" AND 0 ");
                    }
                } else if (paramName.startsWith("GT_")
                        || paramName.startsWith("GE_")
                        || paramName.startsWith("EQ_")
                        || paramName.startsWith("LE_")
                        || paramName.startsWith("LT_")) {

                    // check if this is an extension
                    String fieldname = paramName.substring(3);
                    String[] parts = fieldname.split("#");
                    if (parts.length != 2) {
                        String msg = "The parameter " + paramName
                                + " cannot be recognised.";
                        LOG.info("USER ERROR: " + msg);
                        throw new QueryParameterException(msg);
                    }

                    // extract the operand
                    String op = "=";
                    if (paramName.startsWith("GT_")) {
                        op = ">";
                    } else if (paramName.startsWith("GE_")) {
                        op = ">=";
                    } else if (paramName.startsWith("LE_")) {
                        op = "<=";
                    } else if (paramName.startsWith("LT_")) {
                        op = "<";
                    }

                    // determine sql WHERE clause (depends on param value)
                    String where;
                    Object val = paramValue;
                    try {
                        Integer intVal = (Integer) paramValue;
                        where = "intValue" + op + intVal;
                    } catch (ClassCastException e1) {
                        try {
                            Float floatVal = (Float) paramValue;
                            where = "floatValue" + op + floatVal;
                        } catch (ClassCastException e2) {
                            try {
                                Calendar cal = TimeParser.parseAsCalendar(val.toString());
                                Timestamp ts = new Timestamp(
                                        cal.getTimeInMillis());
                                where = "dateValue" + op + "\"" + ts.toString()
                                        + "\"";
                            } catch (ParseException e) {
                                String strVal = val.toString();
                                where = "strValue" + op + "\"" + strVal + "\"";
                            }
                        }
                    }
                    query.append(" AND `event_" + eventType + "_extensions`.");
                    query.append(where);
                    query.append(" AND `event_" + eventType
                            + "_extensions`.fieldname=\"");
                    query.append(fieldname);
                    query.append("\"");

                } else if (paramName.startsWith("EXISTS_")) {
                    String fieldname = paramName.substring(7);
                    if (fieldname.equals("childEPCs")) {
                        if (eventType.equals("AggregationEvent")) {
                            query.append(" AND (`event_AggregationEvent`.id IN (");
                            query.append("SELECT event_id FROM `event_AggregationEvent_EPCs`");
                            query.append("))");
                        } else {
                            query.append(" AND 0");
                        }
                    } else if (fieldname.equals("epcList")) {
                        query.append(" AND (`event_" + eventType + "`.id IN (");
                        query.append("SELECT event_id FROM `event_" + eventType
                                + "_EPCs`");
                        query.append("))");
                    } else if (fieldname.equals("bizTransactionList")) {
                        query.append(" AND (`event_" + eventType + ".id IN (");
                        query.append("SELECT event_id FROM `event_" + eventType
                                + "_bizTrans`");
                        query.append("))");
                    } else {
                        // lets see if we have an extension fieldname
                        String[] parts = fieldname.split("#");
                        if (parts.length != 2) {
                            // nope, no extension fieldname, just check if
                            // the given type exists
                            query.append(" AND (?) ");
                            queryArgs.add(fieldname);
                        } else {
                            // yep, extension fieldname: check extension table
                            query.append(" AND (`event_" + eventType
                                    + "`.id IN (");
                            query.append("SELECT event_id FROM `event_"
                                    + eventType + "_extensions` ");
                            query.append("WHERE fieldname='" + fieldname + "'");
                            query.append("))");
                        }
                    }

                } else if (paramName.startsWith("HASATTR_")) {
                    // TODO:
                    String msg = "HASATTR_fieldname is not implemented.";
                    LOG.info("USER ERROR: " + msg);
                    throw new UnsupportedOperationException(msg);
                } else if (paramName.startsWith("EQATTR_")) {
                    // TODO:
                    String msg = "EQATTR_fieldname_attrname is not implemented.";
                    LOG.info("USER ERROR: " + msg);
                    throw new UnsupportedOperationException(msg);
                } else if (paramName.equals("orderBy")) {
                    // Does only work correct if we choose only one Event-Type
                    // to query. Otherwise, the Results are ordered by
                    // Event-Types and second according to the orderBy-Parameter
                    orderBy = (String) paramValue;
                } else if (paramName.equals("orderDirection")) {
                    // Does only work correct if we choose only one Event-Type
                    // to query. Otherwise, the Results are ordered by
                    // Event-Types and second according to the orderBy-Parameter
                    orderDirection = (String) paramValue;
                } else if (paramName.equals("eventCountLimit")) {
                    // Does only work properly if we choose only one type to
                    // query.
                    limit = (Integer) paramValue;
                } else if (paramName.equals("maxEventCount")) {
                    maxEventCount = ((Integer) paramValue).intValue();
                } else {
                    String msg = "The parameter " + paramName
                            + " cannot be recognised.";
                    LOG.info("USER ERROR: " + msg);
                    throw new QueryParameterException(msg);
                }
            } catch (ClassCastException e) {
                String msg = "The input value for parameter " + paramName
                        + " (" + paramValue + ") of eventType " + eventType
                        + " is not of the type required.";
                LOG.info("USER ERROR: " + msg);
                throw new QueryParameterException(msg);
            }
        }

        if (maxEvent > -1 && limit > -1) {
            String msg = "The maxEventCount and the eventCountLimit are mutually exclusive.";
            LOG.info("USER ERROR: " + msg);
            throw new QueryParameterException(msg);
        }

        if (orderBy.equals("") && limit > -1) {
            String msg = "eventCountLimit may only be used when orderBy is specified.";
            LOG.info("USER ERROR: " + msg);
            throw new QueryParameterException(msg);
        }

        if (!orderBy.equals("")) {
            query.append(" ORDER BY (?)");
            queryArgs.add(orderBy);
            if (orderDirection.equals("ASC")) {
                query.append(" ASC");
            } else {
                query.append(" DESC");
            }
        }

        if (limit > -1) {
            query.append(" LIMIT " + ((Integer) limit).toString());
        }

        String q = query.toString();
        String qs = q.replaceAll("`", delimiter);
        LOG.debug("QUERY: " + qs);
        PreparedStatement ps = dbconnection.prepareStatement(qs);
        for (int i = 0; i < queryArgs.size(); i++) {
            ps.setString(i + 1, (String) queryArgs.get(i));
            LOG.debug("       query param " + (i + 1) + ": " + queryArgs.get(i));
        }

        return ps;
    }

    /**
     * @see org.accada.epcis.soapapi.EPCISServicePortType#getQueryNames(org.accada.epcis.soapapi.EmptyParms)
     * @param parms
     *            An empty parameter.
     * @return An ArrayOfString containing the names of all implemented queries.
     */
    public ArrayOfString getQueryNames(final EmptyParms parms) {
        ArrayOfString qNames = new ArrayOfString();
        String[] qNamesArray = new String[queryNames.size()];
        qNamesArray = queryNames.toArray(qNamesArray);
        qNames.setString(qNamesArray);
        return qNames;
    }

    /**
     * Subscribes a query.
     * 
     * @see org.accada.epcis.soapapi.EPCISServicePortType#subscribe(org.accada.epcis.soapapi.Subscribe)
     * @param parms
     *            A Subscribe object containing the query to be subscribed..
     * @return Nothing.
     * @throws ImplementationException
     *             If a problem with the EPCIS implementation occured.
     * @throws InvalidURIException
     *             If an invalid URI where the query results should be posted is
     *             provided.
     * @throws SubscribeNotPermittedException
     *             If a SimpleMasterDataQuery is provided which is only valid
     *             for polling.
     * @throws SubscriptionControlsException
     *             If one of the SubscriptionControls parameters is not set.
     * @throws ValidationException
     *             If the query is not valid.
     * @throws DuplicateSubscriptionException
     *             If a query with the given ID is already subscribed.
     * @throws NoSuchNameException
     *             If a query name is not implemented yet.
     */
    public VoidHolder subscribe(final Subscribe parms) throws RemoteException {
        QueryParam[] qParams = parms.getParams();
        URI dest = parms.getDest();
        String subscrId = parms.getSubscriptionID();
        SubscriptionControls controls = parms.getControls();
        String queryName = parms.getQueryName();
        GregorianCalendar initialRecordTime = (GregorianCalendar) parms.getControls().getInitialRecordTime();
        if (initialRecordTime == null) {
            initialRecordTime = new GregorianCalendar();
        }

        try {
            // a few input sanity checks

            // dest may be null or empty. But we don't support pre-arranged
            // destinations and throw an InvalidURIException according to the
            // standard.
            if (dest == null || dest.toString().equals("")) {
                String msg = "Destination URI is empty. This implementation doesn't support pre-arranged destinations.";
                LOG.info("USER ERROR: " + msg);
                throw new InvalidURIException(msg);
            }
            try {
                new URL(dest.toString());
            } catch (MalformedURLException e) {
                String msg = "Destination URI is invalid: " + e.getMessage();
                LOG.info("USER ERROR: " + msg);
                throw new InvalidURIException(msg);
            }

            // check query name
            if (!queryNames.contains(queryName)) {
                String msg = "Illegal query name '" + queryName + "'.";
                LOG.info("USER ERROR: " + msg);
                throw new NoSuchNameException(msg);
            }

            // SimpleMasterDataQuery only valid for polling
            if (queryName.equals("SimpleMasterDataQuery")) {
                String msg = "SimpleMasterDataQuery not permitted for use with subscribe, only with poll.";
                LOG.info("USER ERROR: " + msg);
                throw new SubscribeNotPermittedException(msg);
            }

            // subscriptionID mustn't be empty.
            if (subscrId == null || subscrId.equals("")) {
                String msg = "SubscriptionID is empty. Choose a valid subscriptionID.";
                LOG.info(msg);
                throw new ValidationException(msg);
            }

            // subscriptionID mustn't exist yet.
            if (fetchExistsSubscriptionId(subscrId)) {
                String msg = "SubscriptionID '"
                        + subscrId
                        + "' already exists. Choose a different subscriptionID.";
                LOG.info("USER ERROR: " + msg);
                throw new DuplicateSubscriptionException(msg);
            }

            // trigger and schedule may no be used together, but one of them
            // must be set
            if (controls.getSchedule() != null && controls.getTrigger() != null) {
                String msg = "Schedule and trigger mustn't be used together.";
                LOG.info("USER ERROR: " + msg);
                throw new SubscriptionControlsException(msg);
            }
            if (controls.getSchedule() == null && controls.getTrigger() == null) {
                String msg = "Either schedule or trigger has to be set.";
                LOG.info("USER ERROR: " + msg);
                throw new SubscriptionControlsException(msg);
            }
            if (controls.getSchedule() == null && controls.getTrigger() != null) {
                String msg = "Triggers are not supported.";
                LOG.info("USER ERROR: " + msg);
                throw new SubscriptionControlsException(msg);
            }

            // parse schedule
            Schedule schedule = new Schedule(controls.getSchedule());

            // load subscriptions
            Map<String, SubscriptionScheduled> subscribedMap = loadSubscriptions();

            SubscriptionScheduled newSubscription = new SubscriptionScheduled(
                    subscrId, qParams, dest, controls.isReportIfEmpty(),
                    initialRecordTime, initialRecordTime, schedule, queryName);

            // store the Query to the database
            String insert = "INSERT INTO subscription (subscriptionid, "
                    + "params, dest, sched, trigg, initialrecordingtime, "
                    + "exportifempty, queryname, lastexecuted) VALUES "
                    + "((?), (?), (?), (?), (?), (?), (?), (?), (?))";
            PreparedStatement stmt = dbconnection.prepareStatement(insert);
            LOG.debug("QUERY: " + insert);
            try {
                stmt.setString(1, subscrId);
                LOG.debug("       query param 1: " + subscrId);

                ByteArrayOutputStream outStream = new ByteArrayOutputStream();
                ObjectOutput out = new ObjectOutputStream(outStream);
                out.writeObject(qParams);
                ByteArrayInputStream inStream = new ByteArrayInputStream(
                        outStream.toByteArray());
                stmt.setBinaryStream(2, inStream, inStream.available());
                LOG.debug("       query param 2: [" + inStream.available()
                        + " bytes]");

                stmt.setString(3, dest.toString());
                LOG.debug("       query param 3: " + dest.toString());

                outStream = new ByteArrayOutputStream();
                out = new ObjectOutputStream(outStream);
                out.writeObject(schedule);
                inStream = new ByteArrayInputStream(outStream.toByteArray());
                stmt.setBinaryStream(4, inStream, inStream.available());
                LOG.debug("       query param 4: [" + inStream.available()
                        + " bytes]");

                stmt.setString(5, "");
                LOG.debug("       query param 5: ");

                Calendar cal = newSubscription.getInitialRecordTime();
                Timestamp ts = new Timestamp(cal.getTimeInMillis());
                String time = ts.toString();
                stmt.setString(6, time);
                LOG.debug("       query param 6: " + time);

                stmt.setBoolean(7, controls.isReportIfEmpty());
                LOG.debug("       query param 7: " + controls.isReportIfEmpty());

                stmt.setString(8, queryName);
                LOG.debug("       query param 8: " + queryName);

                stmt.setString(9, time);
                LOG.debug("       query param 9: " + time);

                stmt.executeUpdate();
            } catch (IOException e) {
                String msg = "Unable to store the subscription to the database: "
                        + e.getMessage();
                LOG.error(msg);
                ImplementationException iex = new ImplementationException();
                iex.setReason(msg);
                iex.setStackTrace(e.getStackTrace());
                iex.setSeverity(ImplementationExceptionSeverity.ERROR);
                throw iex;
            }

            // store the new Query to the HashMap
            subscribedMap.put(subscrId, newSubscription);
            saveSubscriptions(subscribedMap);

            return new VoidHolder();
        } catch (SQLException e) {
            String msg = "SQL error during query execution: " + e.getMessage();
            LOG.error(msg, e);
            ImplementationException iex = new ImplementationException();
            iex.setReason(msg);
            iex.setStackTrace(e.getStackTrace());
            iex.setSeverity(ImplementationExceptionSeverity.ERROR);
            throw iex;
        }
    }

    /**
     * This method loads all the stored queries from the database, starts them
     * again and stores everything in a HasMap.
     * 
     * @return A Map mapping query names to scheduled query subscriptions.
     * @throws SQLException
     *             If a problem with the database occured.
     * @throws ImplementationException
     *             If a problem with the EPCIS implementation occured.
     */
    private Map<String, SubscriptionScheduled> fetchSubscriptions()
            throws SQLException, ImplementationException {
        String query = "SELECT * FROM subscription";
        LOG.debug("QUERY: " + query);
        Statement stmt = dbconnection.createStatement();

        GregorianCalendar initrectime = new GregorianCalendar();

        ResultSet rs = stmt.executeQuery(query);
        Map<String, SubscriptionScheduled> subscribedMap = new HashMap<String, SubscriptionScheduled>();
        while (rs.next()) {
            try {
                String subscrId = rs.getString("subscriptionid");

                ObjectInput in = new ObjectInputStream(
                        rs.getBinaryStream("params"));

                QueryParam[] params = (QueryParam[]) in.readObject();
                URI dest = stringToUri(rs.getString("dest"));

                in = new ObjectInputStream(rs.getBinaryStream("sched"));
                Schedule sched = (Schedule) in.readObject();

                initrectime.setTime(rs.getTimestamp("initialrecordingtime"));

                boolean exportifempty = rs.getBoolean("exportifempty");

                String queryName = rs.getString("queryname");

                SubscriptionScheduled newSubscription = new SubscriptionScheduled(
                        subscrId, params, dest, exportifempty, initrectime,
                        new GregorianCalendar(), sched, queryName);
                subscribedMap.put(subscrId, newSubscription);
            } catch (SQLException e) {
                // sql exceptions are passed on
                throw e;
            } catch (Exception e) {
                // all other exceptions are caught
                String msg = "Unable to restore subscribed queries from the database.";
                LOG.error(msg, e);
                ImplementationException iex = new ImplementationException();
                iex.setReason(msg);
                iex.setStackTrace(e.getStackTrace());
                iex.setSeverity(ImplementationExceptionSeverity.SEVERE);
                throw iex;
            }
        }
        rs.close();
        return subscribedMap;
    }

    /**
     * Stops a subscribed query from further invocations.
     * 
     * @see org.accada.epcis.soapapi.EPCISServicePortType#unsubscribe(org.accada.epcis.soapapi.Unsubscribe)
     * @param parms
     *            An Unsubscribe object containing the ID of the query to be
     *            unsubscribed.
     * @return Nothing.
     * @throws ImplementationException
     *             If a problem with the EPCIS implementation occured.
     */
    public VoidHolder unsubscribe(final Unsubscribe parms)
            throws ImplementationException, NoSuchSubscriptionException {
        try {
            Map<String, SubscriptionScheduled> subscribedMap = loadSubscriptions();
            String subscrId = parms.getSubscriptionID();

            if (subscribedMap.containsKey(subscrId)) {
                // remove subscription from local hash map
                SubscriptionScheduled toDelete = subscribedMap.get(subscrId);
                toDelete.stopSubscription();
                subscribedMap.remove(subscrId);
                saveSubscriptions(subscribedMap);

                // delete subscription from database
                String delete = "DELETE FROM subscription WHERE "
                        + "subscriptionid = (?)";
                PreparedStatement stmt = dbconnection.prepareStatement(delete);
                stmt.setString(1, subscrId);
                LOG.debug("QUERY: " + delete);
                LOG.debug("        query param 1: " + subscrId);

                stmt.executeUpdate();
                return new VoidHolder();
            } else {
                String msg = "There is no subscription with ID '" + subscrId
                        + "'.";
                LOG.info("USER ERROR: " + msg);
                throw new NoSuchSubscriptionException(msg);
            }
        } catch (SQLException e) {
            ImplementationException iex = new ImplementationException();
            String msg = "SQL error during query execution: " + e.getMessage();
            LOG.error(msg, e);
            iex.setReason(msg);
            iex.setStackTrace(e.getStackTrace());
            iex.setSeverity(ImplementationExceptionSeverity.ERROR);
            throw iex;
        }
    }

    /**
     * Saves the map with the subscriptions to the message context.
     * 
     * @param subscribedMap
     *            The map with the subscriptions.
     */
    private void saveSubscriptions(
            final Map<String, SubscriptionScheduled> subscribedMap) {
        MessageContext msgContext = MessageContext.getCurrentContext();
        msgContext.setProperty("subscribedMap", subscribedMap);
    }

    /**
     * Retrieves the map with the subscriptions from the servlet context.
     * 
     * @return The map with the subscriptions.
     * @throws ImplementationException
     *             If the map could not be reloaded.
     */
    private Map<String, SubscriptionScheduled> loadSubscriptions()
            throws ImplementationException, SQLException {
        MessageContext msgContext = MessageContext.getCurrentContext();
        Map<String, SubscriptionScheduled> subscribedMap = (HashMap<String, SubscriptionScheduled>) msgContext.getProperty("subscribedMap");
        if (subscribedMap == null) {
            subscribedMap = fetchSubscriptions();
        }
        return subscribedMap;
    }

    /**
     * Returns an ArrayOfString containing IDs of all subscribed queries.
     * 
     * @see org.accada.epcis.soapapi.EPCISServicePortType#getSubscriptionIDs(org.accada.epcis.soapapi.GetSubscriptionIDs)
     * @param parms
     *            An empty parameter.
     * @return An ArrayOfString containing IDs of all subscribed queries.
     * @throws ImplementationException
     *             If a problem with the EPCIS implementation occured.
     */
    public ArrayOfString getSubscriptionIDs(final GetSubscriptionIDs parms)
            throws ImplementationException {
        try {
            Map<String, SubscriptionScheduled> subscribedMap = loadSubscriptions();
            String[] temp = {};
            temp = subscribedMap.keySet().toArray(temp);
            ArrayOfString arrOfStr = new ArrayOfString();
            arrOfStr.setString(temp);
            return arrOfStr;
        } catch (SQLException e) {
            ImplementationException iex = new ImplementationException();
            String msg = "SQL error during query execution: " + e.getMessage();
            LOG.error(msg, e);
            iex.setReason(msg);
            iex.setStackTrace(e.getStackTrace());
            iex.setSeverity(ImplementationExceptionSeverity.ERROR);
            throw iex;
        }
    }

    /**
     * Runs (polls) a query.
     * 
     * @see org.accada.epcis.soapapi.EPCISServicePortType#poll(org.accada.epcis.soapapi.Poll)
     * @param parms
     *            The query to poll.
     * @return A QueryResults object containing the result of the query.
     * @throws ImplementationException
     *             If a problem with the EPCIS implementation occured.
     * @throws QueryTooLargeException
     *             If the query is too large.
     * @throws QueryParameterException
     *             If one of the query parameters is invalid.
     * @throws NoSuchNameException
     *             If an invalid query type was provided.
     */
    public QueryResults poll(final Poll parms) throws ImplementationException,
            QueryTooLargeException, QueryParameterException,
            NoSuchNameException {

        // query type must be implemented.
        if (!queryNames.contains(parms.getQueryName())) {
            String msg = "Invalid query name '" + parms.getQueryName()
                    + "' provided.";
            LOG.info("USER ERROR: " + msg);
            throw new NoSuchNameException(msg);
        }

        String queryName = parms.getQueryName();
        if (queryName.equals("SimpleEventQuery")) {
            try {
                int actEventCount = 0;
                maxEventCount = -1;

                QueryParam[] queryParams = parms.getParams();

                String event = "ObjectEvent";
                PreparedStatement ps = createEventQuery(queryParams, event);
                ObjectEventType[] tempObjectEvent = runObjectEventQuery(ps);
                if (tempObjectEvent != null) {
                    actEventCount += tempObjectEvent.length;
                }

                event = "AggregationEvent";
                ps = createEventQuery(queryParams, event);
                AggregationEventType[] tempAggrEvent = runAggregationEventQuery(ps);
                if (tempAggrEvent != null) {
                    actEventCount += tempAggrEvent.length;
                }

                event = "QuantityEvent";
                ps = createEventQuery(queryParams, event);
                QuantityEventType[] tempQuantityEvent = runQuantityEventQuery(ps);
                if (tempQuantityEvent != null) {
                    actEventCount += tempQuantityEvent.length;
                }

                event = "TransactionEvent";
                ps = createEventQuery(queryParams, event);
                TransactionEventType[] tempTransEvent = runTransactionEventQuery(ps);
                if (tempTransEvent != null) {
                    actEventCount += tempTransEvent.length;
                }

                if (maxEventCount > -1 && actEventCount > maxEventCount) {
                    String msg = "The actual result set (" + actEventCount
                            + ") is larger than the specified maxEventCount ("
                            + maxEventCount + ").";
                    LOG.info("USER ERROR: " + msg);
                    throw new QueryTooLargeException(msg, queryName, null);
                }

                // construct QueryResults
                EventListType eventList = new EventListType();
                eventList.setObjectEvent(tempObjectEvent);
                eventList.setAggregationEvent(tempAggrEvent);
                eventList.setQuantityEvent(tempQuantityEvent);
                eventList.setTransactionEvent(tempTransEvent);

                QueryResultsBody resultsBody = new QueryResultsBody();
                resultsBody.setEventList(eventList);

                QueryResults results = new QueryResults();
                results.setResultsBody(resultsBody);
                results.setQueryName(queryName);

                LOG.info("poll request for '" + queryName + "' succeeded");
                return results;
            } catch (SQLException e) {
                ImplementationException iex = new ImplementationException();
                String msg = "SQL error during query execution: "
                        + e.getMessage();
                LOG.error(msg, e);
                iex.setReason(msg);
                iex.setStackTrace(e.getStackTrace());
                iex.setSeverity(ImplementationExceptionSeverity.ERROR);
                throw iex;
            }
        } else if (queryName.equals("SimpleMasterDataQuery")) {
 			QueryParam[] queryParams = parms.getParams();
 			QueryResults results = new QueryResults();
 			boolean includesAttributes = false;
 			try {
 				PreparedStatement statement = createMasterDataQuery(queryParams, includesAttributes);
 				ResultSet result = statement.executeQuery();
 				if (includesAttributes) {
 					while (result.next()) {
 						LOG.info("QUERY RESULT: uri " + result.getString("uri")+ " attribute " + result.getString("attribute") + " value " +  result.getString("value") );
 					}
 				} else {
 					while (result.next()) {
 						LOG.info("QUERY RESULT: uri " + result.getString("uri"));
 					}
 				}
 			} catch (SQLException e) {
 				// TODO Auto-generated catch block
 				e.printStackTrace();
 			}
 			return results;
		} else {
            String msg = "Invalid query name '" + parms.getQueryName()
                    + "' provided.";
            LOG.info("USER ERROR: " + msg);
            throw new NoSuchNameException(msg);
        }
    }
    
    private PreparedStatement createMasterDataQuery(
			final QueryParam[] queryParams, boolean includesAttributes) throws SQLException,
			QueryParameterException {
		StringBuffer query = new StringBuffer();
		String fromStatement;
		String whereStatement;
		int index;
		List<QueryParam> paramList = Arrays.asList(queryParams);

		// elements will be removed as we go as a control
		List<String> params = new ArrayList<String>();

		// vocabularies queried
		List<String> vocabs = new ArrayList<String>();
		
		// to remember which vocabulary has which result
		Map<String, List<String>> results = new HashMap<String, List<String>>();

		// tables we are extracting from + attributes
		// List<String> tables =

		// Conditions to rememember if we already had a statement of that kind
		boolean firstFromStmt = true;
		boolean firstWhereStmt = true;

		// return size Limit
		int maxElementCount = 0;

		// include children ?
		boolean includeChildren = false;

		// extract parameter names
		for (QueryParam param : paramList) {
			params.add(param.getName());
			LOG.info("Parameter: "+ param.getName() + " added.");
		}
		
		// Required parameters
		index = params.indexOf("includeAttributes");
		LOG.info("Parameter includeAttributes is read.");
		if (paramList.get(index).getValue().equals("true")) {
			includesAttributes = true;
			LOG.info("Parameter includeAttributes is true.");
		}
		params.remove(index);
		
		if(params.contains("includeChildren")){
			index = params.indexOf("includeChildren");
			if (paramList.get(index).getValue().equals("true")) {
				includeChildren = true;
				params.remove(index);
			}
			params.remove(index);
		}

		// Optional parameters
		if (params.contains("maxElementCount")) {
			index = params.indexOf("maxElementCount");
			QueryParam maxCount = paramList.get(index);
			maxElementCount = Integer.parseInt(maxCount.getValue().toString());
			params.remove(index);

			// FROM
			// Either select from
			// -vocabularies given by name (vocabularyName)
			// -vocabularies given by id (EQ_name)
			// or vocabulary is yet to be defined
		} else if (params.contains("vocabularyName")) {
			fromStatement = restrictVocabulary(paramList.get(params.indexOf("vocabularyName")), vocabs);
			params.remove(params.indexOf("vocabularyName"));
			if (vocabs.size() == 0) {
				throw new QueryParameterException(
						"Check arguments of MasterDataQuery with 'vocabularyName' attribute.");
			} else if (params.isEmpty()){
				if (! includesAttributes) {
				query.append("SELECT `uri` " + fromStatement);
				} else {
					String newFromStmt = includeAttributes(vocabs);
					query.append("SELECT * " + newFromStmt);
				}
			}
		} else if (params.contains("EQ_name")) {
			fromStatement = getVocByAttribute(paramList.get(params
					.indexOf("EQ_name")), vocabs);
			params.remove(params.indexOf("EQ_name"));

			// Result aggregation
		} else if (params.contains("attributeNames")) {
			if (includesAttributes) {
				 results.putAll(restrictByAttributes(paramList.get(params
						.indexOf("attributeNames")), vocabs));
				firstWhereStmt = false;
			}
			params.remove(params.indexOf("attributeNames"));
		} else if (params.contains("HASATTR")) {
			hasAttributes(paramList.get(params
					.indexOf("HASATTR")), vocabs);
			params.remove(params.indexOf("HASATTR"));
		}else if (params.contains("WD_name")) {
			// TODO
			params.remove(params.indexOf("WD_name"));
		} 

		// Should be finished here
		if (params.size() > 0) {
			// Or have we still got an EQATTR_attrname parameter ?
			if (params.size() == 1) {
				ListIterator<String> paramIt = params.listIterator();
				String attribute = paramIt.next();
				if (attribute.startsWith("EQATTR_")) {
					attribute = attribute.substring("EQATTR_".length());
					System.out.println("We have found EQATTR_" + attribute
							+ " !");
				}
			} else {
				System.out.println("We have " + params.size()
						+ " parameters left that shouldn't be !");
			}
		}

		// TODO check if delimiters are ok
		LOG.info("QUERY SENT: " + query.toString());
		return dbconnection.prepareStatement(query.toString());
	}

	/**
	 * Refines FromStatement to include attribute tables in result
	 * 
	 * @param vocabs The vocabulary elements to which attributes have to be included
	 * @return a new FromSQL stmt
	 */
	private String includeAttributes(List<String> vocabs) {
		String fromStmt = "FROM ";
		for (String table : vocabs) {
			fromStmt += "`voc_" + table + "` INNER JOIN `" + table + "_attr`";
		}
		return fromStmt;
	}

	private void hasAttributes(QueryParam param, List<String> vocabs) {
		List<String> attr = (List<String>) param.getValue();
		//TODO
	}

	/**
	 * finds out which vocabulary has that attribute TODO: check if correct
	 * 
	 * @param param
	 * @param vocabs
	 * @return
	 * @throws SQLException
	 */
	private Map<String, List<String>> restrictByAttributes(QueryParam param,
			List<String> vocabs) throws SQLException {
		List<String> attr = (List<String>) param.getValue();
		String ATTR_QUERY = "SELECT * FROM ? WHERE `attribute` IN (";
		String VOC_QUERY = "SELECT `uri` FROM ? WHERE `id` = ?";
		Map<String, List<String>> vocMap = new HashMap<String, List<String>>();
		List<String> uris = new ArrayList<String>();
		List<String> attributes = new ArrayList<String>();
		List<String> values = new ArrayList<String>();
		List<String> resultSet = new ArrayList<String>();
		int id = 0;
		int i = 0;

		// construct query
		for (String attrName : attr) {
			ATTR_QUERY += " '" + attrName + "', ";
		}
		ATTR_QUERY += ATTR_QUERY.substring(0, ATTR_QUERY.length() - 2) + ")";

		// execute query
		if (vocabs.size() > 0) {
			for (String voc : vocabs) {
				PreparedStatement s = dbconnection.prepareStatement(ATTR_QUERY);
				s.setString(1, voc + "_extension");
				ResultSet result = s.executeQuery();
				while (result.next()) {
					id = result.getInt("id");
					attributes.add(result.getString("attribute"));
					values.add(result.getString("value"));
					PreparedStatement finalStatement = dbconnection.prepareStatement(VOC_QUERY);
					finalStatement.setString(1, "`voc_" + voc + "`");
					finalStatement.setInt(2, id);
					ResultSet vocUri = finalStatement.executeQuery();
					vocUri.next();
					uris.add( vocUri.getString("uri"));
				}
			}	
		} else {
			System.out
					.println("TODO restrictByAttributes: vocabs not yet defined");
		}
		for(String uri : uris) {
			resultSet.clear();
			resultSet.add(attributes.get(i));
			resultSet.add(values.get(i));
			vocMap.put(uri, resultSet);
			i++;
		}
		return vocMap;
	}

	private String getVocByAttribute(QueryParam param, List<String> vocabs)
			throws SQLException {
		String fromStmt = "FROM ";
		String tableName;
		try {
			List<String> attr = (List<String>) param.getValue();
			for (String uri : attr) {
				tableName = findTableFromUri(uri);
				vocabs.add(tableName.substring(4));
				if (!tableName.equals("")) {
					fromStmt += "`" + tableName + "`, `"
							+ tableName.substring(4) + "_extensions `, ";
				}
			}
			if (fromStmt.endsWith(", ")) {
				fromStmt = fromStmt.substring(0, fromStmt.length() - 2) + " ";
			}
		} catch (ClassCastException e) {
			throw new ClassCastException(e.getMessage());
		}
		return fromStmt;
	}

	private String restrictVocabulary(QueryParam param, List<String> vocabs)
			throws SQLException {
		String tableName;
		String from = "FROM ";
		String GET_VOCI = "SELECT `table_name` FROM `vocabularies` WHERE uri = ";
		try {
			String[] vocis = ((ArrayOfString) param.getValue()).getString();
			for (String uri : vocis) {
				LOG.info("Selecting vocabulary "+uri);
				Statement s = dbconnection.createStatement();
				ResultSet result = s.executeQuery(GET_VOCI + "'" + uri + "'");
				while (result.next()) {
					tableName = result.getString("table_name");
					from += tableName +", ";
				//	LOG.info("Got back table: " + tableName);
					vocabs.add(tableName.substring(4));
				//	LOG.info("Added to vocabs: " + tableName.substring(4));
				} 
			}
		} catch (ClassCastException e) {
			throw new ClassCastException(e.getMessage());
		}
		return from.substring(0, from.length()- 2);
	}

	/**
	 * Searches through all 'voc_*' tables for a uri and returns the name of the
	 * table
	 * 
	 * @param uri
	 *            a vocabulary
	 * @return name of Table which has the <i>uri</i>
	 * @throws SQLException
	 */
	private String findTableFromUri(String uri) throws SQLException {
		List<String> tables = new ArrayList<String>();
		final String GET_VOC_TABLES = "SELECT `table_name` FROM `vocabularies`";
		final String HAS_ID = "SELECT `id` FROM ? WHERE `uri` = ?";

		// get all Vocabulary Tables
		Statement s = dbconnection.createStatement();
		ResultSet result = s.executeQuery(GET_VOC_TABLES);
		while (result.next()) {
			tables.add(result.getString(1));
		}

		// find out which table has vocabulary
		for (String table : tables) {
			PreparedStatement ps = dbconnection.prepareStatement(HAS_ID);
			ps.setString(1, "`" + table + "`");
			ps.setString(2, "'" + uri + "'");
			result = ps.executeQuery();
			if (result.next()) {
				return table;
			}
		}
		return "";
	}
    
    /**
     * Returns the standard version.
     * 
     * @see org.accada.epcis.soapapi.EPCISServicePortType#getStandardVersion(org.accada.epcis.soapapi.EmptyParms)
     * @param parms
     *            An empty parameter.
     * @return The standard version.
     */
    public String getStandardVersion(final EmptyParms parms) {
        return STD_VERSION;
    }

    /**
     * Returns the vendor version.
     * 
     * @see org.accada.epcis.soapapi.EPCISServicePortType#getVendorVersion(org.accada.epcis.soapapi.EmptyParms)
     * @param parms
     *            An empty parameter.
     * @return The vendor version.
     */
    public String getVendorVersion(final EmptyParms parms) {
        return VDR_VERSION;
    }

    /**
     * Checks if the given action values are valid, i.e. all values must be one
     * of ADD, OBSERVE, or DELETE. Throws an exception if one of the values is
     * invalid.
     * 
     * @param action
     *            The action values to be checked.
     * @throws QueryParameterException
     *             If one of the action values are invalid.
     */
    private void checkActionValues(String[] actions)
            throws QueryParameterException {
        for (int i = 0; i < actions.length; i++) {
            if (!(actions[i].equalsIgnoreCase("ADD")
                    || actions[i].equalsIgnoreCase("OBSERVE") || actions[i].equalsIgnoreCase("DELETE"))) {
                String msg = "Invalid value for parameter EQ_action: "
                        + actions[i]
                        + ". Must be one of ADD, OBSERVE, or DELETE.";
                LOG.info("USER ERROR: " + msg);
                throw new QueryParameterException(msg);
            }
        }
    }

}
