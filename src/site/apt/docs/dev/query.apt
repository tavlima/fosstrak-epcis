Developer Guide


* Query Client

  The query interface binding is implemented using Axis 1.4. Although the generation of code is supposed to be automatic, manual modification was sometimes unavoidable. These complications are elaborated {{{query.html#Axis Workaround}here}}.
  An overview of all the classes comprising this package are provided below.

[../../images/queryclient.png]

** QueryControlInterface
  
  The Query Client supports basically two services: 
  
  * Subscription 
  
  * Polling
  
 Polling is a querying mechanism which returns all events satisfying some requirements which are specified through the query parameters. The request is evaluated immediately. Through a <subscription> one may achieve that a query is evaluated multiple times. The frequency is determined by a pattern as defined in the a {{{repository.html#Schedule}<<<Schedule>>>}}. A subscription therefore may also be referred to as a "standing query". This subsription may be revoked by a <<<unsubscribe()>>> command.

** QueryControlClient
  
  The SOAP connector to the {{{repository.html#QueryOperationsModule}<<<QueryOperationsModule>>>}} implementing the subscription and polling operations. The url to which the SOAP request is delivered must be set in the according <<<queryclient.property>>> file.

** QueryCallbackInterface
  
  Query callback is the mechanism how the results of a standing query are delivered. This interface offers a method to report the subscribed query's results. 
  
** QueryCallbackClient

  The <<<QueryCallbackclient>>> is our implementation of a <<<QueryCallbackInterface>>>. The application subscribing a query at the <<<QueryControlclient>>> must indicate a callback destination url in the request.
  At this destination url a <<<HttpServlet>>> is accepting post requests containing query results. The servlet returns a "Callback OK" message if the results were received successfully. These results ar cached until some other application fetches them. An overview of the query callback mechanism is provided {{{query.html#Query Callback}here}}. Implementation details are found {{{query.html#Making use of Axis for query callback}here}}

** QueryClientGui
  
  The User Interface which allows for manual insertion of query attributes. The same interface is used for polling as well as subscription.

** QueryClientGuiHelper
  
  The controller (as in the MVC pattern) of the GUI. It performs integrity checks on the data, does the error handling, marshalls the parameters into a query and forwards it to the stub.
  In contrast to the capturing interface no DOM tree has to be constructed. The conversion from the query parameters to xml and vice versa is done by axis.

** Query

  A model object of a of a real world query. Has mostly setter and getter procedures.

* {Query Callback}

  This sequence diagram shall give an overview over the processing steps a subscribed query goes through, from the time of the subscription until the results are fetched.
  
[../../images/callback.png]

* Axis

** Motivation for the use of Axis v1.4

  Axis 1.4 has been used for the generation of the service stubs, although Version 2.0 is already available. Since Version 2.0 is a complete rewrite using Axis 2.0 would have meant a major rewrite of the XML schema files. This would consequentially have to be done every time a new draft of the upcoming standard is released. Therefore we didn't adapt the current implementation.

** {Axis Workarounds}

  [[1]] {Making use of Axis for Query Callback}
  
    As stated above sending the results of subscribed queries to their destination URI needs serializing an EPCISQueryDocumentType instance with all its parts into XML and then sending it via a HTTP POST request. As we’ve got the Axis genereated Java classes for the needed elements anyway it was obvious to reuse Axis’ XML serializing framework.
    Unfortunately (ab)using Axis for only getting XML back without using the rest of the invocation framework wasn’t envisioned by the Axis developpers and therefore not documented. With the help from the Axis user mailing list the solution for serializing an instance of a class MyClass which has to be the result of a WSDL2Java run was found which is listed below:

+--------------------------------------------------------------------------------------------------------------------------------------------+
      javax.xml.namespace.QName myClassXMLType = myClass Instance.getTypeDesc().getXmlType ();
      OutputStream out = getYourStreamFromSomeObject.getOutputStream();
      OutputStreamWriter oWriter = new OutputStreamWriter(out);
      SerialisationContext serContext = new SerialisationContext(oWriter);
      serContext.setWriteXMLType (myClassXMLType );
      serContext.serialize(myClassXMLType , new NullAttributes( ), myClass Instance, myClassXMLType, myClassInstance.class, false, true);
      oWriter.flush() ;
      out.flush() ;
      oWriter.close() ;
      out.close() ;
+--------------------------------------------------------------------------------------------------------------------------------------------+
  
  [[2]] The <<<ArrayOfString>>> Type and Axis
  
    The file <<<EPCglobal-epcis-query-1 0.xsd>>> defines the type <<<ArrayOfString>>> as an element with a sequence of <<<<string>content</string>>>> elements. Axis 1.4 doesn’t generate a class for this type, but treats it simply as a Java array of <<<String>>> objects. This would be alright if it wouldn’t mix everything up on deserialization because it doesn’t have any type information for <<<ArrayOfString>>>. Our workaround isn’t very elegant but functional. On the receiving (and therefore deserializing) side of the service, add an extra line to <<<EPCglobal-epcisquery-1 0.xsd>>> as shown below which forces Axis to generate a class with an appropriate deserializer. As this lives only on the deserializing end it doesn’t affect the output or standard compliance of the implementation.
    
+-----------------------------------------------------------------------------------------------------------+
    <xsd:complexType name="ArrayOfString">
      <xsd: sequence>
	<xsd: element name="string" type="xsd:string" minOccurs="0" maxOccurs="unbounded"/>
	<xsd: element name="DoNotUseHackAroundBug" type="xsd:boolean" minOccurs="0" maxOccurs="0"/>
      </ xsd: sequence>
    </ xsd:complexType>
+-----------------------------------------------------------------------------------------------------------+